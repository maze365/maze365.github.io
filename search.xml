<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI 相关工具</title>
    <url>/AI-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<p>最近关于 AI 的热度非常高，我也去试用了一下，很厉害，非常惊喜。它的发展上限非常高。<br>推荐几款工具，可以尝试使用下。</p>
<ul>
<li><p><a href="https://yiyan.baidu.com/" target="_blank" rel="noopener">文心一言</a><br>这个是百度的 AI 聊天页面，不过需要申请，现在申请人数很多，审批也很慢。<br>用了几次，发现文心一言对于上下文的理解比较弱。</p>
</li>
<li><p><a href="https://chatdoc.com/chatdoc/" target="_blank" rel="noopener">chatdoc</a><br>这是一款用 AI 开发出来的工具，可以用来解读 PDF，上传 PDF 之后，可以随便问里面相关的内容，是一款很方便的工具。<br>每天限制 5 篇，但没有网络的限制。</p>
</li>
<li><p><a href="https://www.notion.so/zh-cn" target="_blank" rel="noopener">Notion</a><br>这个是一款国外开发的笔记工具，像国内的 wolai 就是参考这个笔记工具开发的。Notion 内置了 AI，调用了 ChatGPT，也就是说不需要去注册 ChatGPT 账号就可以使用了。记得不要用网易邮箱注册账号。<br>不过它只有英文版，想使用中文版的话需要下载它的客户端，然后导入一个中文的翻译文件，网上有相关的教程。我的建议是使用网页版就可以，所谓的客户端实际上还是一个网页，目前优化不是很好，winddows 端缩小化再打开，会白屏几秒。</p>
</li>
</ul>
<p>有限制，注册用户有 20 次的免费提问的机会，次数用完之后需要付费，每个月 $10。</p>
<ul>
<li><p><a href="https://www.cursor.so/" target="_blank" rel="noopener">Cursor | Build Fast</a><br>这是一款 AI 编程的软件，openAI 官方开发的，建议程序员都可以尝试使用下，特别是初学者感觉用处应该最大，目前最新版已经能安装 vscode 的扩展了。<br>相关使用教程可以看这个，非常容易，只需要两个快捷键 ctrl + k，ctrl + l <a href="https://zhuanlan.zhihu.com/p/615818924" target="_blank" rel="noopener">不用科学上网，免费的GPT-4 IDE工具Cursor保姆级使用教程 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://aibot.geekbang.com/" target="_blank" rel="noopener">AI 学习助手 - 极客时间 (geekbang.com)</a><br>这个是我登录极客时间发现居然可以像 AI 提问问题，但是不清楚调用的是哪个 AI。似乎不能开启新话题。</p>
</li>
<li><p>阿里，现在也出了一个 AI 可以申请，不过目前只有公司能申请，还没有开放个人的申请。</p>
</li>
<li><p><a href="https://www.so.com/zt/invite.html#/" target="_blank" rel="noopener">360</a><br>360 的也开始企业内测了，大家都没有说一下子就放开给所有人访问。<br>实际上国内的情况，真的人太多，谁的资源都撑不住，只能限制。</p>
</li>
<li><p><a href="https://www.anthropic.com/" target="_blank" rel="noopener">Claude</a><br><a href="/Claude-使用教程.html">Claude 使用教程</a><br>有个新的 AI 工具叫 claude，没和 GPT 对比，但这个很明显比百度的要优秀。不用科学上网。生成速度和 cursor 一样快，同时还可以返回中文。<br>不过有时候访问会卡顿。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 软件放大和缩小</title>
    <url>/C-%E8%BD%AF%E4%BB%B6%E6%94%BE%E5%A4%A7%E5%92%8C%E7%BC%A9%E5%B0%8F.html</url>
    <content><![CDATA[<p>在软件开发中，实现界面放大和缩小是一项很常见的功能。今天我们来看一下如何开发这样的功能。<br>首先，我们需要一个变量来存储软件当前是放大还是缩小状态，这里使用isMinimized。然后定义正常大小 normalSize 和缩小后的大小 minimizedSize 两个变量。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool isMinimized = <span class="keyword">false</span>; <span class="comment">// 放大和缩小的状态判断</span></span><br><span class="line"><span class="keyword">Size</span> normalSize = <span class="keyword">new</span> <span class="keyword">Size</span>(<span class="number">800</span>, <span class="number">600</span>); <span class="comment">// 正常大小 </span></span><br><span class="line"><span class="keyword">Size</span> minimizedSize = <span class="keyword">new</span> <span class="keyword">Size</span>(<span class="number">200</span>, <span class="number">200</span>); <span class="comment">// 缩小后的大小</span></span><br></pre></td></tr></table></figure></div></p>
<p>在窗口加载时,我们先设置默认大小为 normalSize，并将按钮文本设置为“最小化”。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">this.Size</span> = normalSize<span class="comment">;</span></span><br><span class="line"><span class="attr">minimizeButton.Text</span> = <span class="string">"最小化"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></div></p>
<p>当点击按钮时,我们需要判断当前状态。如果是正常大小,就缩小窗口并更新变量和按钮文本。如果是缩小状态,就还原大小。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIX"><figure class="iseeu highlight /nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isMinimized) </span><br><span class="line">&#123;</span><br><span class="line">    // 最小化 </span><br><span class="line">    this.<span class="attr">Size</span> = minimizedSize;</span><br><span class="line">    label1.<span class="attr">Visible</span> = <span class="literal">false</span>;</span><br><span class="line">    minimizeButton.<span class="attr">Text</span> = <span class="string">"还原"</span>;</span><br><span class="line">    <span class="attr">isMinimized</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    // 还原</span><br><span class="line">    this.<span class="attr">Size</span> = normalSize;</span><br><span class="line">    label1.<span class="attr">Visible</span> = <span class="literal">true</span>;</span><br><span class="line">    minimizeButton.<span class="attr">Text</span> = <span class="string">"最小化"</span>; </span><br><span class="line">    <span class="attr">isMinimized</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="images/20230525_3.png" alt><br>下方是完整的示例代码：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> isMinimized = <span class="literal">false</span>; <span class="comment">// 放大和缩小的状态判断</span></span><br><span class="line">        Size normalSize = <span class="keyword">new</span> Size(<span class="number">800</span>, <span class="number">600</span>); <span class="comment">// 正常大小</span></span><br><span class="line">        Size minimizedSize = <span class="keyword">new</span> Size(<span class="number">200</span>, <span class="number">200</span>); <span class="comment">// 缩小后的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.Size = normalSize;</span><br><span class="line">            minimizeButton.Text = <span class="string">"最小化"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 点击放大缩小按钮的判断事件</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">minimizeButton_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isMinimized)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 最小化</span></span><br><span class="line">                <span class="keyword">this</span>.Size = minimizedSize;</span><br><span class="line">                label1.Visible = <span class="literal">false</span>;</span><br><span class="line">                minimizeButton.Text = <span class="string">"还原"</span>;</span><br><span class="line">                isMinimized = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 还原</span></span><br><span class="line">                <span class="keyword">this</span>.Size = normalSize;</span><br><span class="line">                label1.Visible = <span class="literal">true</span>;</span><br><span class="line">                minimizeButton.Text = <span class="string">"最小化"</span>;</span><br><span class="line">                isMinimized = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Claude 使用教程</title>
    <url>/Claude-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<p>Claude 是由前 openAI 员工开发的聊天机器人，最重要的一点是不用科学上网。</p>
<p><a href="https://www.anthropic.com/" target="_blank" rel="noopener">Claude官网</a></p>
<p>Slack 内置了 Claude 的应用，我们可以在 slack 内置一下这个应用。</p>
<p>注意，申请 Claude 和注册 Slack 都需要用到邮箱，我们两个地方用同一个邮箱就可以。不能用网易和 qq 邮箱，可以注册个 outlook 邮箱。</p>
<h1 id="申请-Claude"><a href="#申请-Claude" class="headerlink" title="申请 Claude"></a>申请 Claude</h1><p>在<a href="https://www.anthropic.com/" target="_blank" rel="noopener">官网</a>上找到 <code>Meet Claude</code> 按钮，等待跳转页面，再点击 <code>Request Access</code> 按钮，弹出一个弹窗，需要我们填写申请资料。只需要填写红色 * 的项。<br>填完之后点击 <code>Submit</code> 点击提交，这个时候会提示申请成功，可以看到一串英文，里面有 <code>Success</code> 就是成功了。<br>这个申请完基本都会提示成功，很快就能用。</p>
<h1 id="注册-Slack"><a href="#注册-Slack" class="headerlink" title="注册 Slack"></a>注册 Slack</h1><p>进入网站<a href="https://www.anthropic.com/claude-in-slack" target="_blank" rel="noopener">Claude in Slack | Anthropic</a>，<br>点击 <code>Add to Slack</code><br><img src="images/Pastedimage20230413152916.png" alt></p>
<p>创建工作区<br><img src="images/Pastedimage20230413153034.png" alt><br>这个时候输入我们的邮箱，会收到邮件验证码，填写就行。</p>
<p>再点击允许，将 Claude 和 Slack 关联在一起。</p>
<h1 id="添加应用"><a href="#添加应用" class="headerlink" title="添加应用"></a>添加应用</h1><p>我们进入到 <a href="https://slack.com" target="_blank" rel="noopener">Slack</a> 页面，类似聊天的界面，我们可以看到左侧会有个应用，下方默认是空的，我们点添加应用，跳转到下图的页面，在右边的搜索栏里面搜索 <code>Claude</code>，将它添加到我们的应用中。<br><img src="images/20230413153527.png" alt></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>2023-5-30 更新<br>可在任意频道里面，先 @Claude，再输入自己想要问的问题。每一个想要获得 claude 回复的问题，都需要加上 @Claude。<br><img src="images/20230530_2.png" alt><br>每一句问题都是独立的，如果我们想要 claude 联系上下文，我们将鼠标悬浮到消息上面，会出现提示文字，接着我们点击查看消息列，在右边的输入聊天框继续输入要提问的问题，也是需要加上 @Claude。<br><img src="images/20230530_4.png" alt><br>注意，不要直接点击 Claude 应用聊天，官方已经禁用掉了，Claude 不会在这里回复。</p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLens 使用教程</title>
    <url>/GitLens-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<p>在 vscode 中 安装了一个 Git 插件，叫 GitLens，这个插件真的太好用了。<br>好久之前就安装上的，但是都没有细看，今天用到了它里面的一些功能，感觉这个软件做得太棒了。稍微写了一下使用方法。</p>
<h1 id="GitLens-设置"><a href="#GitLens-设置" class="headerlink" title="GitLens 设置"></a>GitLens 设置</h1><p>使用 ctrl+shift+P，输入 GitLens: Open Settings<br><img src="images/20230514_9.png" alt><br>点击后会弹出 GitLens 的设置页面，可以进行一些自定义的设置。<br><img src="images/20230514_11.png" alt></p>
<h1 id="查看提交信息"><a href="#查看提交信息" class="headerlink" title="查看提交信息"></a>查看提交信息</h1><p>我们打开我的文本页面，鼠标随便点击某一行，在鼠标停顿的位置后方有一行灰色的注释，内容包括作者姓名，相关日期和提交信息。<br><img src="images/20230514_1.png" alt><br>悬停在注释上面会有更加详细的信息，hash，提交日期，完整的提交信息。这些信息可以让你一眼看到每行代码最后是由谁在什么时候提交的，非常方便代码审查或追踪代码来源。<br><img src="images/20230514_3.png" alt></p>
<h1 id="Toggle-File-Blame"><a href="#Toggle-File-Blame" class="headerlink" title="Toggle File Blame"></a>Toggle File Blame</h1><h2 id="Toggle-File-Blame-1"><a href="#Toggle-File-Blame-1" class="headerlink" title="Toggle File Blame"></a>Toggle File Blame</h2><p>如果我不想只看当前一行后面的注释信息，而是想要查看整个文档文本后面的注释信息，通过点击软件右上角的图标，选择 Toggle File Blame。<br><img src="images/20230514_4.png" alt><br>此时能看到每行文字最后的信息，同样支持悬停。<br><img src="images/20230514_16.png" alt><br>想要关闭的话再点一下右上角的刚刚点击的按钮或者按 ESC 退出。</p>
<h2 id="Toggle-File-Heatmap"><a href="#Toggle-File-Heatmap" class="headerlink" title="Toggle File Heatmap"></a>Toggle File Heatmap</h2><p><img src="images/20230514_12.png" alt><br>Toggle File Heatmap可以为文件添加热度图信息，以视觉方式显示文件每行被更改的频率。当你选择Toggle File Heatmap,在弹出的窗口中，最左侧会显示三种颜色的竖条：</p>
<ul>
<li>蓝色：表示该行未更改或更改少的行。  </li>
<li>红色：表示该行更改频繁的行。  </li>
<li>紫色：表示该行注释或空行。<br>·颜色越深表示该行被更改的次数越多。这让你一眼就能看出文件哪些部分被更改最频繁。<br><img src="images/20230514_14.png" alt></li>
</ul>
<h2 id="Toggle-File-Changes"><a href="#Toggle-File-Changes" class="headerlink" title="Toggle File Changes"></a>Toggle File Changes</h2><p>这个可以让人能很快就知道哪行代码发生了改变。<br>编辑器中会高亮显示自上次 Git 提交后被更改的所有内容。</p>
<ul>
<li>添加的内容会以绿色高亮  </li>
<li>删除的内容会以红色高亮  </li>
<li>修改的内容会以蓝色高亮<br><img src="images/20230514_15.png" alt><h1 id="查看上一次提交"><a href="#查看上一次提交" class="headerlink" title="查看上一次提交"></a>查看上一次提交</h1>下方的按钮，点击后可以打开上一次提交的更改。<br><img src="images/20230514_6.png" alt></li>
</ul>
<p>如果按住 Alt 的同时点击上方圈住的箭头。会跳出更多的 git 提交历史对比列表，这些提交都是本文件的历史提交记录。（这个功能和 vscode 默认的 TIMELINE 功能是一样的。）<br><img src="images/20230514_7.png" alt></p>
<h1 id="左侧菜单"><a href="#左侧菜单" class="headerlink" title="左侧菜单"></a>左侧菜单</h1><p>选中后可以上移和下移重新排序菜单项。<br>或者移动到最左侧的按钮栏使其单独成为一个侧边栏按钮。<br><img src="images/20230514_18.png" alt></p>
<h2 id="SEARCH-amp-COMPARE"><a href="#SEARCH-amp-COMPARE" class="headerlink" title="SEARCH &amp; COMPARE"></a>SEARCH &amp; COMPARE</h2><p>它可以在当前文件或整个仓库中搜索特定的代码，并与 Git tag 或分支进行比较。<br>可以让某个以前的分支与当前版本的代码进行对比。<br><img src="images/20230514_19.png" alt><br>选择钉图标后，就能一直固定这个对比，重启软件也不会消失。<br><img src="images/20230514_20.png" alt></p>
<h2 id="STASHES"><a href="#STASHES" class="headerlink" title="STASHES"></a>STASHES</h2><p>这个经常会用到，我们平时在开发自己的代码，开发到一半，此时需要修改线上分支，又不想要上传这部分代码，会使用临时的 stashes 来暂存起来。</p>
<p>因为我最近用这个功能挺多，但是都是在同一个 git 仓库上，stashes 不小心存太多了，现在想要恢复，又不知道里面到底是改了什么文件，就可以用这个 GitLens 的这个功能，能看到保存的文件修改了哪些内容，用来决定要不要恢复这个存储。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>WORDTREES<br>工作树，和 git 分支有点像。</li>
<li>TAGS<br>标签</li>
<li>FILE HISTRORY<br>当前文件修改的历史记录</li>
<li>COMMITS<br>提交的历史记录。</li>
<li>COMMITS DETAILS<br>上一次提交的详细信息。</li>
</ul>
]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 监听数据变化 defineProperty</title>
    <url>/JS-%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96-defineProperty.html</url>
    <content><![CDATA[<p>Object.defineProperty，它可以监听数据变化，Vue2 内部就是利用 Object.defineProperty() 来实现对数据的监听和响应的。</p>
<p>注：这个是专门给 Object 使用的，其它类型不生效</p>
<p>监听属性变化通过定义 set 方法可以监听属性值改变示例：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;</span><br><span class="line">  message: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(view, <span class="string">'message'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> model.message;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(msg) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'监听到数据发生了变化'</span>)</span><br><span class="line">    model.message = msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">view.message = <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(model.message); <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure></div></p>
<p>其它一些监听值示例：<br>监听 Object 对象的多个值<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = &#123;</span><br><span class="line">	name: <span class="string">"tom"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vm 里边的 name 实际上可以进行监听</span></span><br><span class="line"><span class="built_in">Object</span>.keys(vm).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    definedAttribute(vm, key, vm[key])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">definedAttribute</span>(<span class="params">vm, key, val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"我监听到了数据的变化"</span>)</span><br><span class="line">            <span class="keyword">if</span>(val !== newVal)&#123;</span><br><span class="line">                val = newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 vm 里面的数据</span></span><br><span class="line">vm.name = <span class="string">"jerry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">我监听到了数据的变化 <span class="comment">// 成功进行了监听</span></span><br></pre></td></tr></table></figure></div></p>
<p><a href="https://blog.csdn.net/wengqt/article/details/79945851" target="_blank" rel="noopener">js监听一个变量的变化_wengqt的博客-CSDN博客_js监听</a></p>
<p>其它使用场景：</p>
<ol>
<li><p>定义对象的只读属性可以通过设置 writable 为 false 和不定义 setter 来创建一个只读属性：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'readOnlyProp'</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.readOnlyProp = <span class="number">456</span>; <span class="comment">// 无效,readOnlyProp仍为123</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>私有属性可以在构造函数中定义私有属性，这些属性只能在构造函数内部访问：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> privateProp = <span class="string">'private'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'publicProp'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="keyword">return</span> privateProp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p.publicProp); <span class="comment">// 'private'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.privateProp); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>数据绑定可以通过 getter 和 setter 实现数据的绑定：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;</span><br><span class="line">  message: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(view, <span class="string">'message'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> model.message;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(msg) &#123;</span><br><span class="line">    model.message = msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">view.message = <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(model.message); <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>以上是 Object.defineProperty() 的一些常见使用场景，它提供了更精细地控制对象属性的能力。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Object 拷贝</title>
    <url>/Object-%E6%8B%B7%E8%B4%9D.html</url>
    <content><![CDATA[<h1 id="什么是对象的浅拷贝"><a href="#什么是对象的浅拷贝" class="headerlink" title="什么是对象的浅拷贝"></a>什么是对象的浅拷贝</h1><p>例子<br>当变量相等时，实际上指向的是同一个对象，所以改变 b 的属性值后。a 会被影响到<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="code"><pre><span class="line">let <span class="selector-tag">a</span> = &#123;age: <span class="number">16</span>&#125;</span><br><span class="line">let <span class="selector-tag">b</span> = a</span><br><span class="line"><span class="selector-tag">b</span><span class="selector-class">.age</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">// a.age 也会变成 20</span></span><br></pre></td></tr></table></figure></div></p>
<p>浅拷贝，可以使用以下方法<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="params">...</span>a &#125;</span><br><span class="line"><span class="comment">// vue</span></span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="params">...</span>this.a &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>当修改了 age，不会互相影响<br>浅拷贝时里面的嵌套对象是共享的，还是会被影响，深拷贝时里面的嵌套对象就不会被影响<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  info: &#123;</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="params">...</span>b &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>修改了 name，不会互相影响，如果修改了 info.age，则会互相影响</p>
<h1 id="浅拷贝的方式"><a href="#浅拷贝的方式" class="headerlink" title="浅拷贝的方式"></a>浅拷贝的方式</h1><ol>
<li>Object.assign():<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(&#123;&#125;, b)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>这也会创建一个新的对象 c，并把 b 的所有属性拷贝到 c。<br>Object.assign() 是 ES6 提供的专门用于对象合并的方法，性能较好。</p>
<ol start="2">
<li>扩展运算符 spread 语法:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123; ...b &#125; <span class="comment">// 拷贝对象</span></span><br><span class="line"><span class="keyword">const</span> c = [ ... b] <span class="comment">// 拷贝数组</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>我们已经讲过，这会创建一个新的对象 c，并拷贝 b 的属性到 c。<br>性能中等，略优于手动循环赋值，但不及 Object.assign()。</p>
<ol start="3">
<li>手动循环拷贝:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  c[key] = b[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>这手动循环 b 的属性，并拷贝到 c 中。<br>循环赋值的性能较差，不推荐使用。</p>
<ol start="4">
<li>使用 _.clone():<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = _.clone(obj)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>如前所说，_.clone() 使用 Object.assign() 进行浅拷贝，性能较好。</p>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ol>
<li>JSON.parse(JSON.stringify(obj)):<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(b))</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>这会把对象 b 转换为 JSON 字符串，然后解析该字符串得到一个新对象 c。在这个过程中，嵌套的对象也会被拷贝。</p>
<ol start="2">
<li>手动递归拷贝:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    c[key] = deepCopy(obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = deepCopy(b)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>这定义了一个递归函数 deepCopy()，它会不断调用自己来拷贝嵌套的对象属性。</p>
<ol start="3">
<li>使用 lodash 的 _.cloneDeep():<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = _.cloneDeep(b)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>lodash 中的 _.cloneDeep() 可以完美拷贝一个对象及其嵌套对象。</p>
<p>_.cloneDeep() &gt; 手动递归拷贝 &gt; JSON.parse(JSON.stringify(obj))<br>一些具体的性能对比数据:</p>
<ul>
<li>浅拷贝只需要 0.5ms  </li>
<li>lodash _.cloneDeep 需要 5-10ms  </li>
<li>JSON.parse(JSON.stringify(obj)) 需要 200-500ms</li>
</ul>
<ol>
<li>首先考虑是否真的需要深拷贝 - 浅拷贝的性能是最好的，如果满足需求应首选浅拷贝  </li>
<li>如果需要深拷贝，使用 lodash 的 _.cloneDeep() 方法  </li>
<li>最后才考虑手动递归拷贝或者 JSON.parse(JSON.stringify(obj))</li>
</ol>
<h1 id="在-vue-中"><a href="#在-vue-中" class="headerlink" title="在 vue 中"></a>在 vue 中</h1><p>this.buttons 我需要做一个循环处理判断修改值，1. 直接用 this.buttons for 循环然后变化值，2. 先用变量进行深拷贝后 for 循环处理完值，再赋值回 this.buttons，这两种方式，哪种性能更高</p>
<p>这两种方式的性能差异主要体现在:</p>
<ol>
<li>深拷贝的性能开销</li>
<li>数组的变异(mutation)次数<br>如果直接循环 this.buttons 进行修改，那么数组的变异次数比较高，这会触发 Vue 的依赖追踪和更新机制,降低性能。<br>而先深拷贝一份，循环修改副本，最后再将副本赋值给 this.buttons，数组的变异只发生一次，所以性能会好一些。<br>所以，如果 this.buttons 数组较大，修改的次数也较多，那么推荐：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = _.cloneDeep(<span class="keyword">this</span>.buttons)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>// 循环修改 temp<br>this.buttons = temp<br>如果 this.buttons 较小，只需要做少量修改，那么直接循环修改也问题不大，性能差异不会很明显。<br>综上，建议是:</p>
<ol>
<li>如果只是少量修改，直接循环 this.buttons 也可以</li>
<li>如果涉及大量修改，尤其是大数组，那么深拷贝到一个临时变量，循环修改临时变量,最后再赋值回 this.buttons 是一个更优的方案。</li>
<li>也可以结合 computed property 进行优化,例如:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  editedButtons() &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = _.cloneDeep(<span class="keyword">this</span>.buttons)</span><br><span class="line">    <span class="comment">// 修改 temp</span></span><br><span class="line">    <span class="keyword">return</span> temp </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>在一般环境下,当数组长度达到100-500左右，如果进行大量修改(10-50次以上)，或在 1000 个数组更改其中一个项时，使用拷贝的方法性能会更好，那么使用深拷贝的方式会有比较明显的性能优势。<br>因此我们建议，基本上使用浅拷贝或深拷贝的方式来处理数组数据会比较好。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Object 根据值找键</title>
    <url>/Object-%E6%A0%B9%E6%8D%AE%E5%80%BC%E6%89%BE%E9%94%AE.html</url>
    <content><![CDATA[<p>在 JavaScript 中，对象是一种重要的数据结构，用于储存和组织数据。对象由键值对组成，其中键名用于查找值。但有时候，我们所知道的只是对象中的某个值，需要找到对应的键名。举个简单的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  city: <span class="string">'New York'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里我们有一个 person 对象，包含三个键值对。如果我知道这个人的年龄是 30，但不知道对应键名，我该如何获取呢？<br>为了在 JavaScript 对象中灵活查找键和值，我们需要了解几种遍历对象的方法。</p>
<ol>
<li>获取键和值：Object.keys() 方法返回一个数组,包含对象的所有键名。<br>Object.values() 方法返回一个数组,包含对象的所有值。使用这两个方法，我们可以轻松获取对象的所有键和值。例如:</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  city: <span class="string">'New York'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(person); </span><br><span class="line"><span class="comment">// ['name', 'age', 'city']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = <span class="built_in">Object</span>.values(person);</span><br><span class="line"><span class="comment">// ['John', 30, 'New York']</span></span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>对象遍历：对象遍历指的是迭代对象的属性并访问其键值。主要有以下几种方式：<br>for..in 遍历键：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  city: <span class="string">'New York'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, person[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name John </span></span><br><span class="line"><span class="comment">// age 30</span></span><br><span class="line"><span class="comment">// city New York</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>for..of 遍历值：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">Object</span>.values(person)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// John </span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="comment">// New York</span></span><br></pre></td></tr></table></figure></div></p>
<p>Object.entries() 遍历键值对：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(person)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name John </span></span><br><span class="line"><span class="comment">// age 30</span></span><br><span class="line"><span class="comment">// city New York</span></span><br></pre></td></tr></table></figure></div></p>
<ol start="3">
<li>根据值获取键：</li>
</ol>
<p>Object.entries() + Array.find():通过 Array.find() 直接找到第一个符合条件的键值对，返回键。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> key = <span class="built_in">Object</span>.entries(obj).find(<span class="function">(<span class="params">[_key, value]</span>) =&gt;</span> value === <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(key); <span class="comment">// a</span></span><br></pre></td></tr></table></figure></div></p>
<p>Object.entries()：返回对象所有键值对的数组，然后你可以迭代检查每个键值对，找到你要的键。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// a or c</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>Object.keys():返回对象所有的键，然后你可以迭代检查每个键对应的值，找到你要的键。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj[key] === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// a or c</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>以上三种方法根据对象的值查找对应的键名。 Object.entries() + Array.find() 方法性能最高，其余两种方法性能稍差。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 的基本概念</title>
    <url>/Promise-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content><![CDATA[<p>欢迎来到 ES6 Promise 的入门教程！在这篇文章中，我们将了解 Promise 的基本概念、如何创建和使用它们，以及一些常见的用例。</p>
<h2 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h2><p>Promise 是 JavaScript 中的一个对象，用于表示一个异步操作的最终完成（或失败）及其结果值。简而言之，它是一种对未来可能发生的结果的封装。</p>
<p>在JavaScript中，我们经常需要处理异步操作，例如从服务器获取数据、读取文件或者设置延时等。Promise为我们提供了一种更优雅、易于理解的方法来处理这些操作，让我们的代码更加简洁和可读。</p>
<h2 id="创建-Promise"><a href="#创建-Promise" class="headerlink" title="创建 Promise"></a>创建 Promise</h2><p>要创建一个Promise对象，我们需要使用 <code>new Promise()</code> 构造函数，并提供一个执行器函数作为参数。执行器函数接收两个参数：<code>resolve</code> 和 <code>reject</code>。这两个参数都是函数，分别用于表示异步操作成功执行完成和操作失败。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>在执行器函数中，我们可以进行异步操作（例如发起HTTP请求或者读取文件等），并在操作完成后调用 <code>resolve()</code> 函数。如果操作失败，我们可以调用 <code>reject()</code> 函数。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'操作成功'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<h2 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h2><p>一旦我们有了一个Promise对象，我们可以使用 <code>then()</code> 方法来处理成功的结果。<code>then()</code> 方法接受一个回调函数作为参数，当 Promise 对象被成功解析时，这个回调函数会被执行。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">myPromise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 输出：操作成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>我们还可以使用 <code>catch()</code> 方法来处理Promise被拒绝的情况。它同样接受一个回调函数作为参数，当Promise对象被拒绝时，这个回调函数会被执行。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">myPromise.catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>为了让代码看起来更简洁，我们可以将 <code>then()</code> 和 <code>catch()</code> 方法链接在一起。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">myPromise</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 输出：操作成功</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></div>
<p>此外，我们还可以使用 <code>finally()</code> 方法，不管Promise成功还是失败，都会执行这个方法。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">myPromise</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 输出：操作成功</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'操作完成'</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Promise 为我们处理 JavaScript 中的异步操作提供了一种简洁、可读的方法。在这篇文章中，我们学习了如何创建和使用Promise，以及如何处理成功和失败的情况。在你的项目中使用它们，让代码变得更加优雅和简洁。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 自定义主题</title>
    <url>/hexo%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98.html</url>
    <content><![CDATA[<p>参考文章：<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</a></p>
<p>NexT官方主题配置：<a href="https://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">https://theme-next.iissnan.com/theme-settings.html</a></p>
<p>第三方服务集成：<a href="http://theme-next.iissnan.com/third-party-services.html#comment-system" target="_blank" rel="noopener">http://theme-next.iissnan.com/third-party-services.html#comment-system</a></p>
<h2 id="menu-再多加一个-tags"><a href="#menu-再多加一个-tags" class="headerlink" title="menu 再多加一个 tags"></a>menu 再多加一个 tags</h2><p>找到<code>themes/next/_config.yml</code>，打开<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home</span><br><span class="line">  <span class="meta">#about: /about/ || user</span></span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags  <span class="comment">//将注释去除掉</span></span><br><span class="line">  <span class="meta">#categories: /categories/ || th</span></span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || archive</span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure></div></p>
<p>点开链接，提示 <code>Cannot GET /tags/</code>，不要慌，不能获取tags，创建一个就OK！</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span><span class="string">'name'</span> # 我们这里要创建的是tags，所以这里name改为tags就好</span><br></pre></td></tr></table></figure></div>
<p>在你的网站根目录下面的 source 文件夹会生成 tags 文件夹。</p>
<p>修改 tags 文件夹中的 index.md 文件，新增 type 属性，如下：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-09</span><span class="number">-27</span> <span class="number">11</span><span class="string">:56:43</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div></p>
<p>当你新建一篇博文的时候，增加上tags和categories属性值，就能在tags和categories界面检索到你的文章了。</p>
<h2 id="文章链接格式修改"><a href="#文章链接格式修改" class="headerlink" title="文章链接格式修改"></a>文章链接格式修改</h2><p> 默认文章格式是: <a href="http://xxx.com/2015/07/06/your-title/" target="_blank" rel="noopener">http://xxx.com/2015/07/06/your-title/</a> 的格式的,可以修改成 <a href="http://xxx.com/posts/programming/2016-03-18-hello-world.html" target="_blank" rel="noopener">http://xxx.com/posts/programming/2016-03-18-hello-world.html</a> 这样的格式</p>
<p> 根目录下的 _config.yml 文件<br> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">permalink:</span> posts/<span class="symbol">:category/</span><span class="symbol">:year-</span><span class="symbol">:month-</span><span class="symbol">:day-</span><span class="symbol">:title</span>.html</span><br></pre></td></tr></table></figure></div></p>
<h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p> 改成下图</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/5308475-9f1817d2d7627f7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p> 修改模板 <code>/themes/next/layout/_macro/post.swig</code> ，搜索 <code>rel=&quot;tag&quot;&gt;#</code> ，将 # 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code> </p>
<h2 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部powered By Hexo / 强力驱动</h2><p> 打开 themes/next/layout/_partials/footer.swig,隐藏之间的代码即可，或者直接删除。<br> <img src="http://upload-images.jianshu.io/upload_images/5308475-8e8340c7a0489bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="左侧侧边栏加上展开的分类"><a href="#左侧侧边栏加上展开的分类" class="headerlink" title="左侧侧边栏加上展开的分类"></a>左侧侧边栏加上展开的分类</h2><p> 打开 themes/next/layout/_macro/sidebar.swig<br> 添加内容<br> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="APPLESCRIPT"><figure class="iseeu highlight /applescript"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"category-all-page"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"category-all"</span>&gt;</span><br><span class="line">        &#123;&#123; list_categories(&#123;depth: <span class="number">1</span>&#125;) &#125;&#125;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></div></p>
<p> 参考<a href="https://hexo.io/zh-cn/docs/helpers.html#list-categories" target="_blank" rel="noopener">hexo API</a></p>
<h2 id="添加自定义的css样式"><a href="#添加自定义的css样式" class="headerlink" title="添加自定义的css样式"></a>添加自定义的css样式</h2><p> <code>themes\next\layout\_partials\head.swig</code></p>
<ul>
<li>添加样式支持<br>为了不把原先文件搞得太乱，这里添加自己的样式文件<br>在 <code>themes\next\source\css</code> 文件夹下，打开main.styl文件，在最后添加：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight /scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//My Layer</span></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"_my/style"</span>;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h2 id="首页改成-archives"><a href="#首页改成-archives" class="headerlink" title="首页改成 archives"></a>首页改成 archives</h2><p>我是简单粗暴的将 <code>themes\next\layout</code> 下的 index.swig 的内容改掉，将 archive.swig 的文件内容复制了过来</p>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>安装hexo-generator-searchdb插件<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure></div></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#主题配置文件下，这里改成 true</span></span><br></pre></td></tr></table></figure></div>
<h2 id="首页阅读全文"><a href="#首页阅读全文" class="headerlink" title="首页阅读全文"></a>首页阅读全文</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#主题配置文件下，这里改成true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure></div>
<h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p><a href="https://eggsywelsh.github.io/2016/11/10/hexo%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/" target="_blank" rel="noopener">参考文章</a><br><a href="https://blog.shadowy.me/2018/03/16/hexo-next-macpanel-improved/" target="_blank" rel="noopener">参考文章</a></p>
<p>在 themes/next 目录下打开 _config.yml 配置文件，找到 highlight_theme 属性</p>
<p>这里呢可以配置的属性有normal | night | night eighties | night blue | night bright，你可以挨个试一试，看下效果，选择你喜欢的一个属性</p>
<p>光有这个配置还不行，在你的hexo/目录下_config.yml文件中中，找到，并设置如下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">true</span> <span class="comment">#修改为true</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br></pre></td></tr></table></figure></div>
<h2 id="开启评论"><a href="#开启评论" class="headerlink" title="开启评论"></a>开启评论</h2><p>在 themes/next 目录下打开 _config.yml 配置文件<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#设置为 true</span></span><br><span class="line">  <span class="attr">shortname:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div></p>
<h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>参考文章：<a href="https://blog.csdn.net/Calvin_zhou/article/details/78820718" target="_blank" rel="noopener">https://blog.csdn.net/Calvin_zhou/article/details/78820718</a></p>
<h2 id="文章添加阅读次数，访问量"><a href="#文章添加阅读次数，访问量" class="headerlink" title="文章添加阅读次数，访问量"></a>文章添加阅读次数，访问量</h2><p><a href="https://blog.csdn.net/xr469786706/article/details/78166227" target="_blank" rel="noopener">参考文章</a></p>
<p>打开 \themes\next\ _config.yml 文件<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#改为 true 开启</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span> <span class="comment">#访问人数</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_uv_footer:</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span> <span class="comment">#总访问量</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_pv_footer:</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span> <span class="comment">#单篇文章浏览量</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">page_pv_footer:</span></span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>echarts 增加可移动竖线</title>
    <url>/echarts-%E5%A2%9E%E5%8A%A0%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%AB%96%E7%BA%BF.html</url>
    <content><![CDATA[<p>实现逻辑：<br>在一个 echarts 折线图上，实现两条竖线可随意左右移动的功能，移动停止后，获得竖线此时在 x 轴上的位置。</p>
<p>引入依赖文件<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 我的版本是 5.0.2</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 因为我的是一个 vue 项目，所以加了 vue，没有 vue 的话，普通的也是用同样的方法加载下图表就可以</span><br></pre></td></tr></table></figure></div></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LUA"><figure class="iseeu highlight /lua"><table><tr><td class="code"><pre><span class="line">let data = <span class="string">[[3, 100], [4, 100]]</span> // [x, y] x 是在 x 轴上的位置，y 是竖线的高度，需要比图表 y 轴最大值大</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">shape:</span> <span class="string">&#123;</span></span><br><span class="line">	<span class="attr">x1:</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">	<span class="attr">y1:</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">	<span class="attr">x2:</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">	<span class="attr">y2:</span> <span class="number">4000</span> <span class="string">//</span> <span class="string">竖线的高度</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">x1、y1:线段起点</span>  </span><br><span class="line"><span class="bullet">-</span> <span class="string">x2、y2:线段终点</span></span><br></pre></td></tr></table></figure></div>
<p>draggable<br> // 设置为 true/false 以启用/禁用拖拽，也可以设置为 ‘horizontal’/‘vertical’ 限制只允许水平或垂直方向拖拽。<br> 设置成 true 时，它可以上下左右拖拽，不适合我们的情况，这里我们只要在 x 轴上左右水平拖动，所以设置成 horizontal</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COFFEESCRIPT"><figure class="iseeu highlight /coffeescript"><table><tr><td class="code"><pre><span class="line">ondragend: <span class="function"><span class="params">(params)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> 这个是 x 轴的位置，如果想要变更成不可拖拽的 markline，可以利用这个</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.chart.convertFromPixel(<span class="string">'grid'</span>, params.target.position))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>完整代码如下：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>markline<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"chart"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main2"</span> <span class="attr">style</span>=<span class="string">"height: 430px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">        chart: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">        option1: <span class="literal">null</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.chart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main2'</span>));</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.option1 = &#123;</span></span><br><span class="line"><span class="actionscript">            color: [<span class="string">'#F8CB00'</span>],</span></span><br><span class="line">            grid: &#123;</span><br><span class="line">                left: 40,</span><br><span class="line">                top: 30,</span><br><span class="line">                bottom: 30,</span><br><span class="line">                right: 30,</span><br><span class="line"><span class="actionscript">                containLabel: <span class="literal">false</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            xAxis: [&#123;</span><br><span class="line"><span class="actionscript">                id: <span class="string">'2'</span>,</span></span><br><span class="line"><span class="actionscript">                type: <span class="string">'value'</span>,</span></span><br><span class="line">                min: 0,</span><br><span class="line">                max: 10,</span><br><span class="line">                axisTick: &#123;</span><br><span class="line"><span class="actionscript">                    alignWithLabel: <span class="literal">true</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;],</span><br><span class="line">            yAxis: &#123;</span><br><span class="line"><span class="actionscript">                type: <span class="string">'value'</span>,</span></span><br><span class="line"><span class="actionscript">                id: <span class="string">'2'</span>,</span></span><br><span class="line">                min: 0,</span><br><span class="line">                max: 15,</span><br><span class="line">                interval: 3,</span><br><span class="line">                axisLabel: &#123;</span><br><span class="line"><span class="actionscript">                    formatter: <span class="string">'&#123;value&#125;'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            series: [&#123;</span><br><span class="line"><span class="actionscript">                id: <span class="string">'aaa'</span>,</span></span><br><span class="line"><span class="actionscript">                name: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">                type: <span class="string">'line'</span>,</span></span><br><span class="line"><span class="actionscript">                barWidth: <span class="string">'65%'</span>,</span></span><br><span class="line">                data: [[1, 8.1], [2, 13.3], [3, 1.5], [4, 14.6], [5, 10.8], [6, 9.0], [7, 9.2], [8, 9.3]],</span><br><span class="line">            &#125;],</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.chart.setOption(<span class="keyword">this</span>.option1);</span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.setChart()</span></span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        setChart() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> data = [[<span class="number">3</span>, <span class="number">100</span>], [<span class="number">4</span>, <span class="number">100</span>]] <span class="comment">// [x, y] x 是在 x 轴上的位置，y 是竖线的高度，需要比图表 y 轴最大值大</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> graphicChart = &#123;</span></span><br><span class="line"><span class="javascript">                graphic: data.map(<span class="function">(<span class="params">item, dataIndex</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                        type: <span class="string">'line'</span>,</span></span><br><span class="line">                        z: 100,</span><br><span class="line">                        shape: &#123;</span><br><span class="line">                            x1: 0,</span><br><span class="line">                            y1: 0,</span><br><span class="line">                            x2: 0,</span><br><span class="line"><span class="actionscript">                            y2: <span class="number">4000</span> <span class="comment">// 竖线的高度</span></span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        style: &#123;</span><br><span class="line"><span class="actionscript">                            stroke: <span class="string">'rgba(0,0,0,1)'</span>,</span></span><br><span class="line">                            lineWidth: 1,</span><br><span class="line">                            lineDash: [5, 3]</span><br><span class="line">                        &#125;,</span><br><span class="line"><span class="actionscript">                        bounding: <span class="string">'raw'</span>,</span></span><br><span class="line"><span class="actionscript">                        position: <span class="keyword">this</span>.chart.convertToPixel(<span class="string">'grid'</span>, item),</span></span><br><span class="line"><span class="actionscript">                        cursor: <span class="string">'e-resize'</span>, <span class="comment">// 鼠标修改成可以移动的状态</span></span></span><br><span class="line"><span class="actionscript">                        draggable: <span class="string">'horizontal'</span>, <span class="comment">// 竖线修改成可以移动的状态</span></span></span><br><span class="line"><span class="javascript">                        ondragend: <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">console</span>.log(<span class="keyword">this</span>.chart.convertFromPixel(<span class="string">'grid'</span>, params.target.position))</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.chart.setOption(graphicChart)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>eventBus 发布和订阅</title>
    <url>/eventBus-%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85.html</url>
    <content><![CDATA[<p>eventBus 是一个轻量级的发布/订阅事件总线，主要用于组件之间的松耦合通信。它的原理如下：</p>
<ol>
<li><p>订阅事件：调用 bus.on() 方法订阅某个事件，传入事件名和回调函数。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">eventBus.on(<span class="string">'eventName'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理事件逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>发布事件：调用 bus.emit() 方法发布事件，传入事件名和数据。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">eventBus.emit(<span class="string">'eventName'</span>, data)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>eventBus 会将订阅了该事件的回调函数执行，并传入发布事件的数据。一个简单的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'./eventBus.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">eventBus.on(<span class="string">'eventName'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件 </span></span><br><span class="line">eventBus.emit(<span class="string">'eventName'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h1 id="eventBus-js"><a href="#eventBus-js" class="headerlink" title="eventBus.js"></a>eventBus.js</h1><p>eventBus 的代码，用于引入<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化一个对象,用来存储不同事件名对应的处理函数数组 </span></span><br><span class="line">    <span class="keyword">this</span>.handlers = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(eventName, handler) &#123;</span><br><span class="line">    <span class="comment">// 注册事件,如果该事件名对应的处理函数数组不存在,创建一个空数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.handlers[eventName]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handlers[eventName] = [];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将处理函数添加到该事件名对应的数组中</span></span><br><span class="line">    <span class="keyword">this</span>.handlers[eventName].push(handler); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(eventName, handler) &#123;</span><br><span class="line">    <span class="comment">// 取消订阅事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.handlers[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从处理函数数组中移除指定的处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.handlers[eventName] = <span class="keyword">this</span>.handlers[eventName].filter(h =&gt; h !== handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(eventName, ...args) &#123;</span><br><span class="line">    <span class="comment">// 触发事件,获取该事件名对应的处理函数数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.handlers[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行每个处理函数,并传入事件data</span></span><br><span class="line">    <span class="keyword">this</span>.handlers[eventName].forEach(handler =&gt; handler(...args));   </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 只执行一次</span></span><br><span class="line">  once(eventName, handler) &#123;</span><br><span class="line">    function onceHandler() &#123;</span><br><span class="line">      handler()</span><br><span class="line">      <span class="keyword">this</span>.off(eventName, onceHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.on(eventName, onceHandler) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = new EventBus();</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> eventBus;   </span><br><span class="line"><span class="comment">// 导出 eventBus 实例</span></span><br></pre></td></tr></table></figure></div></p>
<p>它的工作原理是这样的:</p>
<ol>
<li>当调用 on(eventName, handler) 时，handler 函数会被立即注册到 eventBus 中。</li>
<li>当调用 emit(eventName) 时，eventBus 会立即执行以下操作：<ul>
<li>获取 eventName 对应的所有 handler 函数  </li>
<li>在当前执行调用栈中，逐个执行这些 handler 函数这意味着 emit 执行的过程中，所有订阅者的函数都会被调用并执行。举个例子:</li>
</ul>
</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">eventBus.on(<span class="string">"hello"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello A"</span>) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventBus.on(<span class="string">"hello"</span>, () =&gt; &#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello B"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventBus.emit(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></div>
<p>执行以上代码后,会立即输出：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DNS"><figure class="iseeu highlight /dns"><table><tr><td class="code"><pre><span class="line">Hello <span class="keyword">A</span></span><br><span class="line">Hello B</span><br></pre></td></tr></table></figure></div>
<p>这是因为 eventBus.emit(“hello”) 执行的时候，直接调用了两个 handler 函数。所以订阅者可以及时收到消息，不是因为 setTimeout 或者定时器，而是 emit 同步执行了所有订阅函数。</p>
<p>once 的原理是:</p>
<ol>
<li>once() 方法会创建一个内部的 onceHandler 函数</li>
<li>onceHandler 会先执行传入的 handler 函数，然后调用 off() 移除自身</li>
<li>最终 onceHandler 只会执行一次</li>
</ol>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 和 setTimeout 执行顺序</title>
    <url>/Promise-%E5%92%8C-setTimeout-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.html</url>
    <content><![CDATA[<p>promise、setTimeout 等异步 API 的执行顺序和区别。</p>
<p>promise 是 ES6 中用于异步编程的一种解决方案。它可以避免回调地狱的问题。setTimeout 是 JavaScript 中的定时函数，可以在一定的时间后执行代码。当 setTimeout 和 promise 同时使用时，它们两个的执行顺序如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>) <span class="comment">// 主进程</span></span><br><span class="line">  resolve(<span class="string">'Promise then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>) <span class="comment">// 宏任务</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="comment">// 微任务</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>) <span class="comment">// 主进程</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>promise 对象创建时处于 pending 状态。new Promise 里面的内容会立即执行</li>
<li>setTimeout 会首先执行，因为它不需要等待任何操作，作为一个异步任务直接进入事件循环队列。</li>
<li>promise 的 then/catch 被定义，但不会立即执行。</li>
<li>主线程继续执行同步代码，将 then/catch 放入微任务队列。</li>
<li>当主线程执行栈为空时，从微任务队列取出 then/catch 回调并执行。</li>
<li>同时 setTimeout 中的回调函数，会在计时结束后被放入宏任务队列。</li>
<li>主线程执行完所有微任务后，会检查宏任务队列，取出 setTimeout 回调函数并执行。</li>
</ol>
<p>当 JS 引擎执行异步代码时，会按照这个顺序来执行:<br>主线程代码 &gt; 微任务队列 &gt; 宏任务队列<br>也就是:</p>
<ol>
<li>首先执行主线程上的同步代码</li>
<li>主线程代码执行完毕后，检查微任务队列，依次执行所有微任务队列中的任务</li>
<li>微任务队列执行完毕后，检查宏任务队列，依次执行所有宏任务队列中的任务</li>
<li>然后循环往复上述过程<br>其中:</li>
</ol>
<ul>
<li>主线程代码指的是普通的同步代码</li>
<li>微任务包括 promise.then/catch、MutationObserver 等</li>
<li>宏任务包括 setTimeout、setInterval、DOM 事件回调、I/O 操作的回调（网络请求、文件读写、数据库操作）、postMessage/MessageChannel 的事件等<br>所以在异步代码中，我们往往先定义微任务，然后再定义宏任务。这样可以利用微任务的执行优先级，使得需要先执行的逻辑放在微任务中，从而控制代码的执行顺序。</li>
</ul>
<p>执行结果答案<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">执行结果</span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">start</span><br><span class="line"><span class="built_in">Promise</span> then</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure></div></p>
<p>习题，如果我们在 Promise 里面有 setTimeout，外面也有 setTimeout，那么谁会先执行，最终结果是什么呢<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>) <span class="comment">// 宏任务</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>) <span class="comment">// 主进程</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'Promise then'</span>) <span class="comment">// 宏任务</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="comment">// 微任务</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>) <span class="comment">// 主进程</span></span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>python 文本转成 excel</title>
    <url>/python-%E6%96%87%E6%9C%AC%E8%BD%AC%E6%88%90-excel.html</url>
    <content><![CDATA[<p>环境：<br>python：2.7</p>
<h1 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h1><p>在windows下安装pip： 在C:\python27\scirpts下运行<code>easy_install pip</code>进行安装。</p>
<p>如果不知道是哪个路径，去设置变量那里看看就知道</p>
<h1 id="安装-pandas-和-openpyxl"><a href="#安装-pandas-和-openpyxl" class="headerlink" title="安装 pandas 和 openpyxl"></a>安装 pandas 和 openpyxl</h1><p>可以使用国内镜像安装</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="code"><pre><span class="line">pip install pandas -i <span class="string">https:</span><span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure></div>
<p>pip install openpyxl -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>同时需要设置环境参数，<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MEL"><figure class="iseeu highlight /mel"><table><tr><td class="code"><pre><span class="line">.../<span class="keyword">python</span>  这个是 <span class="keyword">python</span> 的环境参数</span><br><span class="line"><span class="comment">// 需要加多一个</span></span><br><span class="line">../<span class="keyword">python</span>/Script</span><br></pre></td></tr></table></figure></div></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>可以使用 Pandas 库的 sort_values() 方法对 DataFrame 进行排序。</p>
<p>例如，如果要按 project 列进行排序，可以这样写：</p>
<p>Copy code<br>df = df.sort_values(‘project’)<br>这将按 project 列的值对 DataFrame 进行排序。</p>
<p>如果要按多列进行排序，可以使用 by 参数指定排序列，例如：</p>
<p>Copy code<br>df = df.sort_values(by=[‘project’, ‘date’])<br>这将按 project 列和 date 列的值对 DataFrame 进行排序。</p>
<p>如果要按降序排序，可以使用 ascending 参数设置为 False，例如：</p>
<p>Copy code<br>df = df.sort_values(by=’project’, ascending=False)<br>这将按 project 列的值从大到小对 DataFrame 进行排序。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  # 必须加上这个，否则就识别不了中文</span></span><br><span class="line"><span class="comment"># 引入一些库，需要使用 pip 安装</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> openpyxl.utils.dataframe <span class="keyword">import</span> dataframe_to_rows</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是 text，也就是我的工作日报的格式，用这个来解析成 excel</span></span><br><span class="line">text = <span class="string">"""</span></span><br><span class="line"><span class="string"># 日期</span></span><br><span class="line"><span class="string">项目名称</span></span><br><span class="line"><span class="string">- [x] 工作项1</span></span><br><span class="line"><span class="string">- [x] 工作项2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将工作日报文本转换为 DataFrame</span></span><br><span class="line">df = pd.DataFrame(columns=[<span class="string">'date'</span>, <span class="string">'project'</span>, <span class="string">'task'</span>])</span><br><span class="line"></span><br><span class="line">lines = text.strip().split(<span class="string">'\n'</span>)</span><br><span class="line">project_str = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="keyword">if</span> line.startswith(<span class="string">'#'</span>):</span><br><span class="line">        date = <span class="string">'2022-'</span> + line[<span class="number">1</span>:].strip()</span><br><span class="line">        project_str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">elif</span> line.startswith(<span class="string">'-'</span>):</span><br><span class="line">        task = line.replace(<span class="string">'- [x] '</span>, <span class="string">''</span>)</span><br><span class="line">        df = df.append(&#123;<span class="string">'date'</span>: date, <span class="string">'project'</span>: project_str, <span class="string">'task'</span>: task&#125;, ignore_index=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        project_str = line</span><br><span class="line">df = df.sort_values(by=<span class="string">'project'</span>, ascending=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 将 DataFrame 写入 Excel 文件</span></span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> dataframe_to_rows(df, index=<span class="literal">False</span>, header=<span class="literal">True</span>):</span><br><span class="line">    ws.append(r)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">"work_log.xlsx"</span>)</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 父组件想判断所有子组件弹窗是否有打开</title>
    <url>/vue-%E7%88%B6%E7%BB%84%E4%BB%B6%E6%83%B3%E5%88%A4%E6%96%AD%E6%89%80%E6%9C%89%E5%AD%90%E7%BB%84%E4%BB%B6%E5%BC%B9%E7%AA%97%E6%98%AF%E5%90%A6%E6%9C%89%E6%89%93%E5%BC%80.html</url>
    <content><![CDATA[<p>vue + element<br>情况，希望在子组件有弹窗打开时，父组件的一些快捷键功能不要触发，因此需要知道子组件弹窗的打开状态。<br>父组件一个页面<br>子组件可以有多个页面</p>
<p>子组件 1<br>通过 computed 以及 watch 监听状态，将开启和关闭状态返回到父组件，代码示例如下<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog :visible.sync=<span class="string">"isVisible"</span>&gt;&lt;/el-dialog&gt;</span><br><span class="line">computed: &#123;</span><br><span class="line">	dialogState() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.isVisible</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">watch: &#123;</span><br><span class="line">	dialogState(<span class="keyword">val</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.$emit(<span class="string">'dialogState'</span>, <span class="keyword">val</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>子组件 2<br>子组件 2 有多个 el-dialog 弹窗，也是使用 computed 以及 watch 监听，代码如下<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog :visible.sync=<span class="string">"isVisible"</span>&gt;&lt;/el-dialog&gt;</span><br><span class="line">&lt;el-dialog :visible.sync=<span class="string">"isVisible2"</span>&gt;&lt;/el-dialog&gt;</span><br><span class="line">computed: &#123;</span><br><span class="line">	dialogState() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.isVisible || <span class="keyword">this</span>.isVisible2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">watch: &#123;</span><br><span class="line">	dialogState(<span class="keyword">val</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.$emit(<span class="string">'dialogState'</span>, <span class="keyword">val</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>父组件<br>监听弹窗状态的函数我们使用了相同的函数</p>
<ul>
<li>定义一个 <code>dialogOpenCount</code> 计数器，初始为 0 </li>
<li>在 <code>dialogState</code> 方法中，为 true <code>dialogOpenCount</code> 加 1，为 false，<code>dialogOpenCount</code> 减 1  <ul>
<li>如果减到 0，表示两个子组件的弹窗都关闭了</li>
<li>如果还大于 0，表示还有弹窗打开<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="code"><pre><span class="line">&lt;com1 <span class="meta">@dialogState</span>=<span class="string">"dialogState"</span>&gt;&lt;/com1&gt;</span><br><span class="line">&lt;com2 <span class="meta">@dialogState</span>=<span class="string">"dialogState"</span>&gt;&lt;/com2&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> () &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		dialogOpenCount: <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">	<span class="comment">// 两个检查子组件弹窗是否显示的判断</span></span><br><span class="line">	dialogState(<span class="keyword">val</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">val</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.dialogOpenCount++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.dialogOpenCount--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime 插件删除不成功</title>
    <url>/sublime%20%E6%8F%92%E4%BB%B6%E5%88%A0%E9%99%A4%E4%B8%8D%E6%88%90%E5%8A%9F.html</url>
    <content><![CDATA[<p>删除 sublime 插件步骤：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CMAKE"><figure class="iseeu highlight /cmake"><table><tr><td class="code"><pre><span class="line">Ctrl+Shift+P调出命令面板，输入<span class="keyword">remove</span>，调出<span class="keyword">Remove</span> Package选项并回车，选择要删除的插件并回车；</span><br></pre></td></tr></table></figure></div></p>
<p>打开 <code>preferences</code> - <code>package settings</code> 查看，插件还在，浏览程序包也在。<br>直接删除插件包，插件包重新生成了。</p>
<p>用 <code>ctrl+~</code> 查看控制台，发现了下面的报错信息。<br><code>ImportError: No module named &#39;package_control&#39;</code></p>
<p>以下是解决方法：<br>打开<code>设置-用户</code>的配置文件（非汉化版应该是 <code>user settings</code>）<br><img src="/images/sublime1.png" alt></p>
<p>删除其中一行代码，保存<br><img src="/images/sublime2.png" alt></p>
<p>再重新执行删除的步骤，成功。</p>
]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器 requestAnimationFrame</title>
    <url>/%E5%AE%9A%E6%97%B6%E5%99%A8-requestAnimationFrame.html</url>
    <content><![CDATA[<p>requestAnimationFrame 是什么？<br>它是一个浏览器提供的 API，用于在浏览器重绘之前调用指定的回调函数。它可以让浏览器在重绘之前更新动画/视觉效果，从而实现平滑的动画效果。</p>
<p>使用场景：requestAnimationFrame 经常用来构建平滑的动画效果和视觉效果。比如页面滚动，CSS3 过渡和动画，canvas 动画等。</p>
<p>原理：requestAnimationFrame 将回调函数加入浏览器的回调队列中,在下一次重绘之前调用。一般来说,屏幕刷新频率是 60Hz，也就是说每秒重新绘制 60 次。requestAnimationFrame 试图将重绘与此刷新频率同步，从而实现平滑的动画效果。</p>
<p>与 setTimeout/setInterval 的比较：<br>requestAnimationFrame 与 setTimeout/setInterval 都可以实现定时执行代码的功能，但 requestAnimationFrame 有更好的性能表现。这是因为:</p>
<ul>
<li>requestAnimationFrame 与屏幕刷新同步，只在需要重绘的时候执行回调，而 setTimeout 是按照固定时间间隔执行。</li>
<li>requestAnimationFrame 会把多个回调集中在一起执行，减少重绘次数,而 setTimeout 会每个时间间隔就重绘一次。</li>
<li>requestAnimationFrame 可以保证平滑的动画效果，而 setTimeout 可能由于间隔时间过长产生卡顿感。<br>所以,在不需要严格的时间间隔要求和需要平滑动画的场景下，requestAnimationFrame 是更好的选择。</li>
</ul>
<p>不同浏览器的实现差异：<br>不同浏览器的刷新频率可能不同,实现方式也可能略有差异，这可能会导致动画效果在不同浏览器中有细微的差别。<br>在我的电脑上，屏幕的刷新率是 60Hz，它每一次的刷新频率大概是 16.666ms。</p>
<p>优点：</p>
<ol>
<li>与屏幕刷新频率同步，实现平滑的动画效果；</li>
<li>节省 CPU、GPU 和电量；</li>
<li>避免布局抖动等视觉差异。</li>
</ol>
<p>缺点：</p>
<ol>
<li>回调函数的调用频率受屏幕刷新频率的限制,在低刷新频率下会感觉到卡顿；</li>
<li>若连续调用 requestAnimationFrame，可能会导致过高的 CPU 占用，应避免请求动画帧的频率超过屏幕刷新频率；</li>
<li>部分低端机型的刷新频率较低,动画效果可能不太平滑。</li>
</ol>
<p>使用示例：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行动画绘制等逻辑</span></span><br><span class="line">  requestAnimationFrame(animate); </span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animate);</span><br></pre></td></tr></table></figure></div></p>
<p>可以使用 cancelAnimationFrame 取消一个 requestAnimationFrame 的回调函数。例如：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rafId;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行动画绘制等逻辑</span></span><br><span class="line">  rafId = requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAnimation</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  rafId = requestAnimationFrame(animate); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消 requestAnimationFrame</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cancelAnimationFrame(rafId); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-electron 批量生成 pdf</title>
    <url>/vue-electron%20%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%20pdf.html</url>
    <content><![CDATA[<blockquote>
<p>最近有个需求，需要批量下载 pdf，单份还好，但多份时会超时。<br>需要改成一份一份下载，先选择下载的存储路径，再自动下载到选择的目录中，一开始使用了 will-download，但在测试过程中，测服下载速度很慢，发现保存地址还是会弹出来，下载一次弹出一份。<br>因此打算试试利用 electron 原来的生成 pdf 功能</p>
</blockquote>
<blockquote>
<p>计划利用一个隐藏窗口来生成PDF，打开隐藏窗口后，加载数据，判断加载完成后，开始生成 PDF 页面，会涉及到 electron 的打开新窗口、选择文件夹、生成 PDF 三个功能</p>
</blockquote>
<p>官方API</p>
<ul>
<li>选择存储目录 <a href="https://www.electronjs.org/docs/api/dialog" target="_blank" rel="noopener">对话框 showOpenDialog</a></li>
<li>打开新窗口 <a href="https://www.electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">BrowserWindow</a></li>
<li>生成 PDF <a href="https://www.electronjs.org/docs/api/web-contents#contentsprinttopdfoptions" target="_blank" rel="noopener">printToPDF</a></li>
<li>窗口间通信 <a href="https://www.electronjs.org/docs/api/ipc-main" target="_blank" rel="noopener">ipcMain</a></li>
</ul>
<p>开发环境：electron4+</p>
<h1 id="选择存储目录"><a href="#选择存储目录" class="headerlink" title="选择存储目录"></a>选择存储目录</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TYPESCRIPT"><figure class="iseeu highlight /typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听方法一般放在 created 就行</span></span><br><span class="line">    ipcRenderer.on(<span class="string">'selected-directory'</span>, <span class="function">(<span class="params">event, path</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileSavePath = path</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">ipcRenderer.send(<span class="string">'select-file-dialog'</span>)</span><br><span class="line"></span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    <span class="comment">// 因为 .on 监听方法会一直存在，导致多次监听，所以每次退出页面把监听移除掉就行了</span></span><br><span class="line">    ipcRenderer.removeAllListeners(<span class="string">'selected-directory'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COFFEESCRIPT"><figure class="iseeu highlight /coffeescript"><table><tr><td class="code"><pre><span class="line">&lt;!--main.js--&gt;</span><br><span class="line">const &#123;ipcMain, dialog&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line">ipcMain.<span class="literal">on</span>(<span class="string">'select-file-dialog'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</span><br><span class="line">  dialog.showOpenDialog(&#123;</span><br><span class="line">    title: <span class="string">'选择文件夹'</span>,</span><br><span class="line">    buttonLabel: <span class="string">'确定'</span>,</span><br><span class="line">    properties: [<span class="string">'openFile'</span>, <span class="string">'openDirectory'</span>]</span><br><span class="line">  &#125;, <span class="function"><span class="params">(files)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (files) &#123;</span><br><span class="line">    <span class="regexp">//</span> 将得到的路径传回页面存起来</span><br><span class="line">      event.sender.send(<span class="string">'selected-directory'</span>, files)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
<h1 id="打开新窗口"><a href="#打开新窗口" class="headerlink" title="打开新窗口"></a>打开新窗口</h1><h2 id="主进程打开新窗口并跳到某个页面"><a href="#主进程打开新窗口并跳到某个页面" class="headerlink" title="主进程打开新窗口并跳到某个页面"></a>主进程打开新窗口并跳到某个页面</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TYPESCRIPT"><figure class="iseeu highlight /typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;href&#125; = <span class="keyword">this</span>.$router.resolve(&#123;</span><br><span class="line">    name: urlName,</span><br><span class="line">    query: &#123; id: <span class="keyword">this</span>.id, pdfPath: <span class="keyword">this</span>.pdfPath&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ipcRenderer.send(<span class="string">'open-window'</span>, <span class="string">`<span class="subst">$&#123;href&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sideWIndow</span><br><span class="line">ipcMain.on(<span class="string">'open-window'</span>, <span class="function">(<span class="params">event, _data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 判断下隐藏窗口是否存在，如果不存在才打开一个新窗口</span></span><br><span class="line">  <span class="keyword">if</span> (!sideWIndow) &#123;</span><br><span class="line">    sideWIndow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">      width: <span class="number">1280</span>,</span><br><span class="line">      height: <span class="number">720</span>,</span><br><span class="line">      show: <span class="literal">false</span> <span class="comment">// 是否隐藏窗口，在测试过程中，可以先改成 true 来看跳转的页面是否正确</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断了下是否是开发环境</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html<span class="subst">$&#123;_data&#125;</span>`</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    url = <span class="string">`http://localhost:9080<span class="subst">$&#123;_data&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子窗口加载页面</span></span><br><span class="line">  sideWIndow.loadURL(url)</span><br><span class="line">  sideWIndow.on(<span class="string">'closed'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    sideWIndow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 关闭窗口的指令</span></span><br><span class="line">ipcMain.on(<span class="string">'close-window'</span>, <span class="function">(<span class="params">event, _data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sideWIndow) &#123;</span><br><span class="line">    sideWIndow.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
<h2 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COFFEESCRIPT"><figure class="iseeu highlight /coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 退出此页面时，关闭窗口</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    ipcRenderer.send(<span class="string">'close-window'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 主窗口有个关闭窗口事件，我们在这里也加个判断，把隐藏窗口一起关了</span><br><span class="line">mainWindow.<span class="literal">on</span>(<span class="string">'closed'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (sideWindow) &#123;</span><br><span class="line">      sideWindow.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
<h1 id="生成-pdf"><a href="#生成-pdf" class="headerlink" title="生成 pdf"></a>生成 pdf</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MOONSCRIPT"><figure class="iseeu highlight /moonscript"><table><tr><td class="code"><pre><span class="line">// 这里生成报告页还是一份一份生成的，只要在前端遍历，有接收到生成成功的信号，就在下载下一份就可以了</span><br><span class="line">// html</span><br><span class="line">// 生成 PDF 需要一个存储路径，以及文件名</span><br><span class="line">ipcRenderer.send(<span class="string">'print-all-pdf'</span>, <span class="string">'E:\name.pdf'</span>)</span><br><span class="line">// 接收</span><br><span class="line">ipcRenderer.on(<span class="string">'wrote-all-pdf'</span>, <span class="function"><span class="params">(event, data)</span> =&gt;</span> &#123;</span><br><span class="line">    console.log(<span class="string">'报告下载成功！'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!<span class="comment">--main.js--&gt;</span></span><br><span class="line">// 生成 PDF 放在同个页面新建窗口的同一个页面</span><br><span class="line">// mainWindow 是主窗口,用来接收子窗口下载报告成功的指令</span><br><span class="line">const fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">ipcMain.on(<span class="string">'print-all-pdf'</span>, <span class="function"><span class="params">(event, _data)</span> =&gt;</span> &#123;</span><br><span class="line">  const pdfPath = _data</span><br><span class="line">  sideWindow.webContents.printToPDF(&#123;&#125;, <span class="function"><span class="params">(<span class="built_in">error</span>, data)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">error</span>) console.<span class="built_in">error</span>(<span class="built_in">error</span>)</span><br><span class="line">    fs.writeFile(pdfPath, data, <span class="function"><span class="params">(<span class="built_in">error</span>)</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">        console.<span class="built_in">error</span>(<span class="built_in">error</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">        mainWindow.webContents.send(<span class="string">'wrote-all-pdf-err'</span>, pdfPath)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mainWindow.webContents.send(<span class="string">'wrote-all-pdf'</span>, pdfPath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">ipcMain.on(<span class="string">'print-err-pdf'</span>, <span class="function"><span class="params">(event, _data)</span> =&gt;</span> &#123;</span><br><span class="line">  mainWindow.webContents.send(<span class="string">'wrote-all-pdf-err'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
<p>在下载成功的时候，可以触发事件去下载下一份报告</p>
]]></content>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>对象解构赋值</title>
    <url>/%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>在 JS 中，有一个表达式是解构，它允许从对象或数组中提取值，并将值赋给变量。在开发中使用，能让我们的代码变得更加简洁。</p>
<p>比如：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = [<span class="string">'John'</span>, <span class="number">30</span>, <span class="string">'New York'</span>]</span><br><span class="line"><span class="keyword">var</span> name = person[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> age = person[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> city = person[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构后</span></span><br><span class="line"><span class="keyword">var</span> person = [<span class="string">'John'</span>, <span class="number">30</span>, <span class="string">'New York'</span>]</span><br><span class="line"><span class="keyword">var</span> [name, age, city] = person</span><br></pre></td></tr></table></figure></div></p>
<h1 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h1><p>以下的赋值语法默认使用了 ES6，部分老旧的浏览器是不支持这样赋值的。<br>对对象而言，解构赋值相当于为多个属性创建不同的变量名，例如:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  city: <span class="string">'New York'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = person; <span class="comment">// 这个是 ES6 新增的解构赋值</span></span><br><span class="line"><span class="comment">// name = 'John', age = 30</span></span><br></pre></td></tr></table></figure></div></p>
<p>这里我们从 person 对象中解构出 name 和 age 属性，分别赋值给同名变量。这是一个非常实用的语法，可以让我们快速从对象中获取所需的属性。</p>
<p>非 ES6 语法进行赋值<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> name = person.name;</span><br><span class="line"><span class="keyword">const</span> age = person.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">'Apple'</span>, <span class="string">'Orange'</span>, <span class="string">'Banana'</span>];</span><br><span class="line"><span class="keyword">const</span> first = fruits[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> second = fruits[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></div></p>
<p>解构的变量名不需要与属性同名，我们可以在解构语句中自定义变量名：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: firstName, age &#125; = person;</span><br><span class="line"><span class="comment">// firstName = 'John', age = 30</span></span><br></pre></td></tr></table></figure></div></p>
<p>这里我们将 name 属性解构到 firstName 变量。解构赋值语句可以有默认值，这样即使属性不存在，变量也会有值：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age = <span class="number">20</span> &#125; = person; </span><br><span class="line"><span class="comment">// name = 'John', age = 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, height = <span class="number">180</span> &#125; = person; </span><br><span class="line"><span class="comment">// name = 'John', height = 180</span></span><br></pre></td></tr></table></figure></div></p>
<p>height 属性不存在，所以 height 变量取默认值 180。</p>
<p>解构嵌套对象：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'John'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    street: <span class="string">'Main St'</span>,</span><br><span class="line">    city: <span class="string">'New York'</span>,</span><br><span class="line">    state: <span class="string">'NY'</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">address</span>: &#123; street, city &#125; &#125; = user;</span><br><span class="line"><span class="comment">// street = 'Main St'</span></span><br><span class="line"><span class="comment">// city = 'New York'</span></span><br></pre></td></tr></table></figure></div></p>
<h1 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h1><p>我们上面举的例子都是对象解构，下面说明数组解构，也是类似的：<br>基本语法是：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// x = 1, y = 2</span></span><br></pre></td></tr></table></figure></div></p>
<p>交换变量的值：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="comment">// a = 2, b = 1</span></span><br></pre></td></tr></table></figure></div></p>
<p>这里我们从数组中解构出 x 和 y 两个值。如果解构不成功,值就等于 undefined：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">// x = 1, y = undefined</span></span><br></pre></td></tr></table></figure></div></p>
<p>解构可以嵌套，从多维数组中解构：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y], z] = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]; </span><br><span class="line"><span class="comment">// x = 1, y = 2, z = 3</span></span><br></pre></td></tr></table></figure></div></p>
<p>解构也可以有默认值：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y = <span class="number">2</span>] = [<span class="number">1</span>]; </span><br><span class="line"><span class="comment">// x = 1, y = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="number">3</span>] = [<span class="number">1</span>, <span class="literal">null</span>]; </span><br><span class="line"><span class="comment">// x = 1, y = null // null 被认为是一个合法的值，所以 y 取值为 null 而非默认值 3。</span></span><br></pre></td></tr></table></figure></div></p>
<p>数组解构赋值经常用于从函数返回多个值,并直接赋给不同的变量。例如：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'John'</span>,</span><br><span class="line">    <span class="number">30</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [name, age] = getUser();</span><br><span class="line"><span class="comment">// name = 'John', age = 30</span></span><br></pre></td></tr></table></figure></div></p>
<p>我们从 getUser() 的返回值中直接解构出 name 和 age 变量。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>用 GitHub + hexo 搭建博客</title>
    <url>/%E7%94%A8-GitHub-hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content><![CDATA[<ul>
<li>系统：win7 64x</li>
<li>nodejs：v10.8.0</li>
<li><p>npm：6.2.0</p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><blockquote>
<p><a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a><br>这里我下载了msi程序包。</p>
</blockquote>
</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step2.png" alt="image"><br>一直点击下一步安装就行了。</p>
<ul>
<li>安装完成后，检测 PATH 环境变量是否配置了 Node.js，点击开始 -&gt; 运行 -&gt; 输入 [ cmd ]  -&gt; 在 dos 窗口中输入命令 [ path ] ，输出如下结果：</li>
</ul>
<blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TAGGERSCRIPT"><figure class="iseeu highlight /taggerscript"><table><tr><td class="code"><pre><span class="line">&gt; PATH=C:<span class="symbol">\o</span>raclexe<span class="symbol">\a</span>pp<span class="symbol">\o</span>racle<span class="symbol">\p</span>roduct<span class="symbol">\1</span>0.2.0<span class="symbol">\s</span>erver<span class="symbol">\b</span>in;C:<span class="symbol">\W</span>indows<span class="symbol">\s</span>ystem32;</span><br><span class="line">&gt; C:<span class="symbol">\W</span>indows;C:<span class="symbol">\W</span>indows<span class="symbol">\S</span>ystem32<span class="symbol">\W</span>bem;C:<span class="symbol">\W</span>indows<span class="symbol">\S</span>ystem32<span class="symbol">\W</span>indowsPowerShell<span class="symbol">\v</span>1.0<span class="symbol">\;</span></span><br><span class="line">&gt; c:<span class="symbol">\p</span>ython32<span class="symbol">\p</span>ython;C:<span class="symbol">\M</span>inGW<span class="symbol">\b</span>in;C:<span class="symbol">\P</span>rogram Files<span class="symbol">\G</span>TK2-Runtime<span class="symbol">\l</span>ib;</span><br><span class="line">&gt; C:<span class="symbol">\P</span>rogram Files<span class="symbol">\M</span>ySQL<span class="symbol">\M</span>ySQL Server 5.5<span class="symbol">\b</span>in;C:<span class="symbol">\P</span>rogram Files<span class="symbol">\n</span>odejs<span class="symbol">\;</span></span><br><span class="line">&gt; C:<span class="symbol">\U</span>sers<span class="symbol">\r</span>g<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\n</span>pm</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>我们可以看到环境变量中已经包含了C:\Program Files\nodejs\</p>
<blockquote>
<p>我在这里不是安装的c盘</p>
</blockquote>
<p>使用以下命令验证是否安装成功</p>
<ul>
<li>node -v</li>
<li><p>npm -v</p>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><blockquote>
<p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a> </p>
</blockquote>
</li>
</ul>
<p><img src="/images/Snipaste_2018-09-26_16-56-51.png" alt></p>
<p>安装好后可以在开始菜单栏看到git</p>
<ul>
<li>Git Bath 命令行模式</li>
<li>Git GUI 图形界面</li>
</ul>
<p>回到电脑桌面，鼠标右击如果看到有两个git单词则安装成功</p>
<p><img src="/images/Snipaste_2018-09-26_16-57-32.png" alt></p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ul>
<li>首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</li>
<li>然后在文件夹中右击打开git命令框(Git Bash)</li>
<li>[ npm install -g hexo-cli ] 使用npm安装Hexo ,在git命令框中安装Hexo </li>
<li>[ hexo init ] 初始化<br>新建完成后，指定文件夹的目录如下：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQF"><figure class="iseeu highlight /sqf"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<blockquote>
<p>我在这里出现了 hexo: command not found 的错误，通过搜索，发现是hexo没有添加到环境变量，最后顺利解决。<a href="https://blog.csdn.net/whjkm/article/details/42675579" target="_blank" rel="noopener">参考文章</a> ，没有差错请忽视 quote 文字</p>
</blockquote>
<blockquote>
<p>添加环境变量 <a href="https://jingyan.baidu.com/article/47a29f24610740c0142399ea.html" target="_blank" rel="noopener">参考文章</a></p>
</blockquote>
<blockquote>
<ul>
<li>打开hexo的安装路径，我是安装在e盘，路径如下 [ E:\hexo\node-v10.8.0-win-x64\node-global\node_modules\hexo-cli\bin ] </li>
<li>第一种方法：我的电脑 -&gt; 右键 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 找到 [ path ] 选择 -&gt; 编辑，加上分号 [ ; ]把路径 [ E:\hexo\node-v10.8.0-win-x64\node-global\node_modules\hexo-cli\bin ] 拷贝进来</li>
<li>第二种方法，点击开始 -&gt; 运行 -&gt; 输入 [ sysdm.cpl ]  -&gt; 高级 -&gt; 环境变量 -&gt; 找到 [ path ] 选择 -&gt; 编辑，加上分号 ; 把路径 [ E:\hexo\node-v10.8.0-win-x64\node-global\node_modules\hexo-cli\bin ] 拷贝进来</li>
<li>环境变量配置好后，记得把 git 关掉再重新打开</li>
</ul>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAMS"><figure class="iseeu highlight /gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> npm install -g hexo-cli </span><br><span class="line"><span class="symbol">$</span> hexo init &lt;folder&gt;  新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</span><br><span class="line"><span class="comment">// 我这里输入 hexo init blog ，完成后会在文件夹下新建了一个blog的文件夹来存放网站</span></span><br><span class="line"><span class="symbol">$</span> cd &lt;folder&gt; <span class="comment">// 切换到站点根目录</span></span><br><span class="line"><span class="comment">// 输入 cd blog</span></span><br><span class="line"><span class="symbol">$</span> npm install</span><br><span class="line"><span class="symbol">$</span> hexo g <span class="comment">// generetor的缩写  生成博客静态文件</span></span><br><span class="line"><span class="symbol">$</span> hexo s <span class="comment">// server的缩写 启动本地服务器</span></span><br></pre></td></tr></table></figure></div>
<p>浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 访问 </p>
<p>成功了！！！</p>
<h2 id="hexo主题更换"><a href="#hexo主题更换" class="headerlink" title="hexo主题更换"></a>hexo主题更换</h2><p>显示的是默认的主题，这里我们可以更换主题</p>
<p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题</a></p>
<p><a href="https://www.haomwei.com/" target="_blank" rel="noopener">https://www.haomwei.com/</a> 响应式的主题</p>
<p>github 上有大量的主题可供选择，这里我选择使用 nexT 主题，<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> </p>
<ul>
<li><p>下载主题相关文件</p>
</li>
<li><p>1.第一种方法：可以直接在此网站下载文件，下载后放到当前目录下的 themes 里面的 next 文件夹中。( next 文件夹自己新建 )</p>
</li>
<li><p>2.第二种方法：在此文件夹 -&gt; 右键 -&gt; 打开命令提示符 -&gt; 输入 [ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next ]</p>
<blockquote>
<p>以上代码的意思是从 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> 将 next 下载到当前目录下的 themes 里面的 next 文件夹中。</p>
</blockquote>
</li>
<li><p>更换主题</p>
</li>
<li>打开配置文件( 配置文件就是根目录下的 _config.yml 文件 )</li>
<li>查找到 theme 字段，后面跟着的 landscape 是默认的主题，改成我们现在下载的 next 就可以了</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOIT"><figure class="iseeu highlight /autoit"><table><tr><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAMS"><figure class="iseeu highlight /gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> hexo clean  <span class="comment">// 清除缓存</span></span><br><span class="line"><span class="symbol">$</span> hexo g  <span class="comment">// 重新生成代码</span></span><br><span class="line"><span class="symbol">$</span> hexo s  <span class="comment">// 部署到本地</span></span><br><span class="line"><span class="comment">//然后打开浏览器访问 localhost:4000 查看效果</span></span><br></pre></td></tr></table></figure></div>
<p>nexT主题有三种选择，这个只是最简洁的一种，我们选择最好看的那个。</p>
<blockquote>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
</blockquote>
<ul>
<li>在 站点根目录/themes/next/_congig.yml 文件中修改</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AVRASM"><figure class="iseeu highlight /avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">scheme:</span> Pisces</span><br></pre></td></tr></table></figure></div>
<p>然后重新clean，generator，server查看效果:</p>
<p>可以自定义主题，甚至修改源码，定制自己的主题，具体请查看<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官网文档</a></p>
<h2 id="将本地博客上传到-GitHub"><a href="#将本地博客上传到-GitHub" class="headerlink" title="将本地博客上传到 GitHub"></a>将本地博客上传到 GitHub</h2><ol>
<li>注册 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></li>
<li>创建新项目( New repository )</li>
<li><p>按格式输入项目名称( Repository name ) </p>
<blockquote>
<p>项目名必须为：用户名.github.io 。把 [ Initialize this repository with a README ] 勾选上</p>
</blockquote>
</li>
<li><p>点击设置( setting ) </p>
</li>
<li>往下拉，找到 GitHub pages ，choose theme 选择则一个主题，随便选，后面会覆盖掉</li>
</ol>
<blockquote>
<p>这个时候访问一下你的链接，应该可以看到效果，接下来将我们Hexo的代码部署到github上</p>
</blockquote>
<ol start="6">
<li>修改hexo站点的配置文件 _config.yml，修改如下</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LESS"><figure class="iseeu highlight /less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/maze365.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br><span class="line">    <span class="comment">//冒号后面要有空格，缩进为两个空格</span></span><br></pre></td></tr></table></figure></div>
<p>7.使用 git 部署一下就好了<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAMS"><figure class="iseeu highlight /gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> npm install hexo-deployer-git --save</span><br><span class="line"><span class="comment">//装个插件</span></span><br><span class="line"><span class="symbol">$</span> hexo d  <span class="comment">//  部署的命令</span></span><br><span class="line"><span class="comment">//等一会就好了</span></span><br></pre></td></tr></table></figure></div></p>
<h2 id="发布你的第一篇博客"><a href="#发布你的第一篇博客" class="headerlink" title="发布你的第一篇博客"></a>发布你的第一篇博客</h2><p>git 根目录下输入 ：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">"postName"</span></span><br><span class="line"> <span class="comment">//hexo n 也可以 </span></span><br><span class="line"> <span class="comment">//你自己的博客名称，名为postName.md的文件会建在目</span></span><br><span class="line"> <span class="comment">//录/blog/source/_posts下。</span></span><br></pre></td></tr></table></figure></div></p>
<p>文章编辑完成后，执行如下命令来发布:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAMS"><figure class="iseeu highlight /gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> hexo g <span class="comment">//生成静态页面</span></span><br><span class="line"><span class="symbol">$</span> hexo d <span class="comment">//发布</span></span><br></pre></td></tr></table></figure></div></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"postName"</span> #新建文章</span><br><span class="line">$ hexo new<span class="built_in"> page </span><span class="string">"pageName"</span> #新建页面</span><br><span class="line">$ hexo generate #生成静态页面至public目录</span><br><span class="line">$ hexo<span class="built_in"> server </span>#开启预览访问端口（默认端口4000，<span class="string">'ctrl + c'</span>关闭server）</span><br><span class="line">$ hexo deploy #将.deploy目录部署到GitHub </span><br><span class="line">$ hexo help # 查看帮助</span><br><span class="line">$ hexo version #查看Hexo的版本</span><br></pre></td></tr></table></figure></div>
<h2 id="重启-hexo"><a href="#重启-hexo" class="headerlink" title="重启 hexo"></a>重启 hexo</h2><p>关闭服务器后，再次重启<br>在站点根目录下 git<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install</span><br><span class="line"><span class="variable">$ </span>hexo g</span><br><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure></div></p>
<p> 参考文章：<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">https://blog.csdn.net/Hoshea_chx/article/details/78826689</a></p>
<p> 参考文章：<a href="https://blog.csdn.net/AinUser/article/details/77609180" target="_blank" rel="noopener">https://blog.csdn.net/AinUser/article/details/77609180</a></p>
<p> <a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">hexo官网</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>隐藏文件管理资源器左侧的坚果云快捷方式</title>
    <url>/%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90%E5%99%A8%E5%B7%A6%E4%BE%A7%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<p>系统：windows 10<br>在安装了坚果云之后，发现在左边有一个快捷方式，现在我想要隐藏掉，具体操作如下</p>
<p>按 Win + R 打开“运行”对话框,输入 regedit 打开注册表编辑器，编辑器打开后点击“编辑”-“查找”:<br>我们可以看到有坚果云的字样<br><img src="images/20230520_1.png" alt></p>
<ol>
<li>找到名称为“System.IsPinnedToNamespaceTree”的注册表项</li>
<li>双击修改该项,将“值数据”一栏从当前值修改为“0”</li>
<li>点击“确定”保存设置</li>
<li>重启资源管理器或电脑</li>
<li>之前的“坚果云”快捷方式应隐藏,如果要显示,将第2步的值改回原来的值即“1”<br><img src="images/20230520_2.png" alt></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>解除端口占用</title>
    <url>/%E8%A7%A3%E9%99%A4%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8.html</url>
    <content><![CDATA[<p>打开 dos 命令窗口输入一下命令</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">netstat -o -n -a <span class="string">| findstr :4000</span></span><br></pre></td></tr></table></figure>
<p>可以看到输出如下：<br><img src="images/20220902172812.png" alt><br>可以看到 LISTENING 同时端口是 4000 那一行，最后面带着一串数字，数字是 3628，这个时候我们输出一行命令，解除掉占用<br><img src="images/20230409134012.png" alt><br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">taskkill <span class="string">/F</span> <span class="string">/PID</span> 3628</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>纯 html 文件中怎么使用 sass</title>
    <url>/%E7%BA%AF-html-%E6%96%87%E4%BB%B6%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-sass.html</url>
    <content><![CDATA[<p>sass 是一种流行的 CSS 预处理器，它能够让开发者使用嵌套语法和变量，以及一些其他的便利功能，来更加高效地编写 CSS 样式表。</p>
<blockquote>
<p>没有使用 npm 安装 sass，在平时的纯 html 页面中，要怎么才能使用 sass</p>
</blockquote>
<h1 id="安装-Ruby"><a href="#安装-Ruby" class="headerlink" title="安装 Ruby"></a>安装 Ruby</h1><p><a href="http://www.ruby-lang.org/zh_cn/downloads/" target="_blank" rel="noopener">http://www.ruby-lang.org/zh_cn/downloads/</a></p>
<h1 id="安装-sass"><a href="#安装-sass" class="headerlink" title="安装 sass"></a>安装 sass</h1><p>cmd 命令行输入下面的命令</p>
<pre><code>gem install sass
</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><blockquote>
<p>文件夹名称不能是中文，否则会编译失败</p>
</blockquote>
<ul>
<li>单文件编译</li>
</ul>
<!---->
<pre><code>sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css
</code></pre><ul>
<li><p>多文件编译<br>sass sass/\:css/（表示“sass”文件夹中所有的”.scss”文件编译成”.css”文件，并且将这些css文件放到“css”文件夹中）</p>
</li>
<li><p>自动监测（主要使用）<br><code>sass --watch&lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css</code>（.scss文件每次修改按ctrl+s保存都会实时的反映到输出的.css文件中）</p>
</li>
</ul>
<!---->
<pre><code>:expanded 普通样式
:compact 一个样式一行
:compressed 所有样式一行
</code></pre><p>先打开命令行工具，进入到具体的文件夹，然后再执行使用命令。</p>
<p>例子：<br>我有一个项目放在了 <code>E</code> 盘，名称叫 <code>sass-project</code>，里面有一个 <code>sass</code> 和 <code>css</code> 文件夹。<br>打开 <code>cmd</code>,<code>E:</code>进入到 E 盘，然后使用 <code>cd</code> 进入到 <code>sass-project</code>文件夹，接下来执行下面的命令就行</p>
<pre><code>sass --watch sass:css --style compact
</code></pre><!---->
<pre><code>ctrl+c 停止
</code></pre><p><img src="/images/2023-3-11-1.png" alt="image"></p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>　　$blue : #1875e7;　
　　div {
　　　color : $blue;
　　}
</code></pre><h2 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a>计算功能</h2><pre><code>　　body {
　　　　margin: (14px/2);
　　　　top: 50px + 100px;
　　　　right: $var * 10%;
　　}
</code></pre><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><pre><code>　　div {
　　　　h1 {
　　　　　　color:red;
　　　　}
　　}
　　border-color属性
　　p { 
　　　　border: {
　　　　　　color: red;
　　　　}
　　}
　　a:hover
　　a {
　　　　&amp;:hover { color: #ffb3ff; }
　　}
</code></pre><h2 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a>代码的重用</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code>.class1 {
　　　　border: 1px solid #ddd;
　　}
　　.class2 {
　　　　@extend .class1;
　　　　font-size:120%;
　　}
</code></pre><h3 id="Mixin-重用代码块-可以指定参数和缺省值"><a href="#Mixin-重用代码块-可以指定参数和缺省值" class="headerlink" title="Mixin (重用代码块) 可以指定参数和缺省值"></a>Mixin (重用代码块) 可以指定参数和缺省值</h3><pre><code>　　@mixin left {
　　　　float: left;
　　　　margin-left: 10px;
　　}
　　div {
　　　　@include left;
　　}
</code></pre><p>eg: mixin的实例，用来生成浏览器前缀</p>
<pre><code>　　@mixin rounded($vert, $horz, $radius: 10px) {
　　　　border-#{$vert}-#{$horz}-radius: $radius;
　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;
　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;
　　}
　　&lt;!--调用--&gt;
　　#navbar li { @include rounded(top, left); }
　　#footer { @include rounded(top, left, 5px); }
</code></pre><h2 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h2><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p>
<pre><code>　　lighten(#cc3, 10%) // #d6d65c
　　darken(#cc3, 10%) // #a3a329
　　grayscale(#cc3) // #808080
　　complement(#cc3) // #33c
</code></pre><h2 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a>插入文件</h2><pre><code>@import &quot;path/filename.scss&quot;;
@import &quot;foo.css&quot;;
</code></pre><h1 id="支持中文注释方法"><a href="#支持中文注释方法" class="headerlink" title="支持中文注释方法"></a>支持中文注释方法</h1><ul>
<li>在 scss 文件头加上 <code>@charset &quot;utf-8&quot;;</code></li>
<li>查看出错的 css 文件</li>
</ul>
<!---->
<pre><code>Backtrace:
sass/shop.scss:4
C:/Ruby26/lib/ruby/gems/2.6.0/gems/sass-3.7.3/lib/sass/util.rb:1090:in `rescue in block in find_encoding_error&apos;
C:/Ruby26/lib/ruby/gems/2.6.0/gems/sass-3.7.3/lib/sass/util.rb:1087:in `block in find_encoding_error&apos;
C:/Ruby26/lib/ruby/gems/2.6.0/gems/sass-3.7.3/lib/sass/util.rb:1086:in `each&apos;
C:/Ruby26/lib/ruby/gems/2.6.0/gems/sass-3.7.3/lib/sass/util.rb:1086:in `each_with_index&apos;
C:/Ruby26/lib/ruby/gems/2.6.0/gems/sass-3.7.3/lib/sass/util.rb:1086:in `find_encoding_error&apos;
C:/Ruby26/lib/ruby/gems/2.6.0/gems/sass-3.7.3/lib/sass/util.rb:820:in `rescue in check_sass_encoding&apos;
</code></pre><p>得到路径 <code>C:/Ruby26/lib/ruby/gems/2.6.0/gems/sass-3.7.3/lib/sass</code></p>
<p>里面有一个文件<code>engine.rb</code>打开</p>
<pre><code>require &apos;sass/scss&apos;
require &apos;sass/stack&apos;
require &apos;sass/error&apos;
require &apos;sass/importers&apos;
require &apos;sass/shared&apos;
require &apos;sass/media&apos;
require &apos;sass/supports&apos;
</code></pre><p>我们在一连串的 require 后面加上代码</p>
<pre><code>Encoding.default_external = Encoding.find(&apos;utf-8&apos;)
</code></pre><p>最后再重启 sass 一下就好了</p>
<p>更详细的使用可以参考：<a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/sass.html</a></p>
]]></content>
      <tags>
        <tag>sass</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>用 C# 开发小软件.md</title>
    <url>/%E7%94%A8C-%E5%BC%80%E5%8F%91%E5%B0%8F%E8%BD%AF%E4%BB%B6.html</url>
    <content><![CDATA[<p>之前同事发给我一个软件，是  C# 写的，非常的小巧，比 electron 小太多了。最近突发奇想想要自己尝试写一个小软件。</p>
<p>需求如下：<br>三个按钮，第一个按钮叫记录，第二个按钮叫暂停，点击记录按钮记录当前时间，显示在页面上，点击暂停按钮记录当前时间显示在页面上，并计算两个时间的时间差，以时-分的格式显示在软件上。 继续点击记录和暂停按钮，继续计算时间差，并和上一次记录的时间差进行一个累加同样显示在页面上。 最后一个按钮命名清空，可以清空页面上所有文本信息。</p>
<p>开发环境：Visual Studio 2015</p>
<h2 id="步骤-1-创建-Windows-窗体应用程序"><a href="#步骤-1-创建-Windows-窗体应用程序" class="headerlink" title="步骤 1 - 创建 Windows 窗体应用程序"></a>步骤 1 - 创建 Windows 窗体应用程序</h2><p>首先，我们需要创建一个新的 Windows 窗体应用程序。打开 Visual Studio，并在菜单中选择 “文件” -&gt; “新建” -&gt; “项目”。在 “新建项目” 对话框中，选择 “Windows 窗体应用程序” 并为其命名（例如：TimeRecorder）。然后，点击 “确定” 按钮创建新项目。这个时候 Visual Studio 会自动为我们创建一个空的窗体应用程序。</p>
<h2 id="步骤-2-添加-UI-控件"><a href="#步骤-2-添加-UI-控件" class="headerlink" title="步骤 2 - 添加 UI 控件"></a>步骤 2 - 添加 UI 控件</h2><p>接下来，我们需要向窗体中添加三个按钮(Button)和一些文本框(Label)用于显示时间记录信息。在 Visual Studio 的工具箱中，找到按钮控件并拖动三个按钮到窗体上。另外，也从工具箱中拖动三个文本框控件到窗体上，一个用于显示开始时间，另一个用于显示结束时间，还有一个显示时间差。</p>
<p><img src="images/20230422_1.png" alt></p>
<h2 id="步骤-3-编写事件处理程序"><a href="#步骤-3-编写事件处理程序" class="headerlink" title="步骤 3 - 编写事件处理程序"></a>步骤 3 - 编写事件处理程序</h2><p>当用户单击任何一个按钮时，需要调用一个事件处理程序来执行相应的操作。双击按钮，Visual Studio 将自动在源代码文件中创建事件处理程序。</p>
<p>首先，在窗体类中添加成员变量来保存开始和结束时间：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> DateTime startTime;</span><br><span class="line">    <span class="keyword">private</span> DateTime endTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>接下来，定义每个按钮的单击事件处理程序。记录按钮单击事件将保存当前时间并在开始时间文本框中显示它：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnRecord_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    startTime = DateTime.Now;</span><br><span class="line">    txtStart.Text = startTime.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>暂停按钮单击事件将保存当前时间并在结束时间文本框中显示它。然后计算时间差，并在时间差文本框中显示它：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATHEMATICA"><figure class="iseeu highlight /mathematica"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private void btnPause_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    endTime = DateTime.<span class="keyword">Now</span>;</span><br><span class="line">    txtEnd.<span class="keyword">Text</span> = endTime.<span class="keyword">ToString</span>();</span><br><span class="line"></span><br><span class="line">    TimeSpan timeDiff = endTime - startTime;</span><br><span class="line">    txtTimeDiff.<span class="keyword">Text</span> = string.<span class="keyword">Format</span>(<span class="string">"&#123;0:00&#125;:&#123;1:00&#125;"</span>,</span><br><span class="line">        (int)timeDiff.TotalHours, timeDiff.Minutes);</span><br><span class="line"></span><br><span class="line">    startTime = DateTime.<span class="keyword">MinValue</span>;</span><br><span class="line">    endTime = DateTime.<span class="keyword">MinValue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>最后一个按钮是清空按钮，它将清空所有文本框：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">private</span> void <span class="keyword">btnClear_Click(object </span>sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    txtStart<span class="meta">.Text</span> = <span class="string">""</span><span class="comment">;</span></span><br><span class="line">    txtEnd<span class="meta">.Text</span> = <span class="string">""</span><span class="comment">;</span></span><br><span class="line">    txtTimeDiff<span class="meta">.Text</span> = <span class="string">""</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h2 id="步骤-4-绑定按钮"><a href="#步骤-4-绑定按钮" class="headerlink" title="步骤 4 - 绑定按钮"></a>步骤 4 - 绑定按钮</h2><p>在程序中，文本框我们使用了 <code>txtStart</code>，’txtEnd’，’txtTimeDiff’ 三个，我们需要做下绑定。</p>
<p>单机一下设计图的 label，在右边找到 Name 属性，分别依次改成上面三个值。</p>
<p><img src="images/20230422_2.png" alt></p>
<h2 id="步骤-5-运行程序"><a href="#步骤-5-运行程序" class="headerlink" title="步骤 5 - 运行程序"></a>步骤 5 - 运行程序</h2><p>现在，我们已经完成了这个简单的应用程序的开发。按 F5 键运行应用程序，然后单击记录按钮来记录时间。单击暂停按钮来结束计时并显示时间差。可以一次又一次地按下记录和暂停按钮以记录更多时间段。最后，单击清空按钮清空所有文本框。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>以下是完整的 C# 代码，可以复制并粘贴到 Form1.cs 文件中：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">setTime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> DateTime startTime;</span><br><span class="line">        <span class="keyword">private</span> DateTime endTime;</span><br><span class="line">        <span class="keyword">private</span> TimeSpan totalTimeDiff;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            button2.Enabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnRecord_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            startTime = DateTime.Now;</span><br><span class="line">            txtStart.Text = <span class="string">"开始："</span> + startTime.ToString();</span><br><span class="line">            txtEnd.Text = <span class="string">""</span>;</span><br><span class="line">            button1.Enabled = <span class="literal">false</span>; <span class="comment">// 禁止按钮点击</span></span><br><span class="line">            button2.Enabled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnPause_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            endTime = DateTime.Now;</span><br><span class="line">            txtEnd.Text = <span class="string">"结束："</span> + endTime.ToString();</span><br><span class="line"></span><br><span class="line">            TimeSpan timeDiff = endTime - startTime;</span><br><span class="line">            totalTimeDiff += timeDiff;</span><br><span class="line">            txtTimeDiff.Text = <span class="string">"时间差："</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:00&#125;:&#123;1:00&#125;:&#123;2:00&#125;"</span>,</span><br><span class="line">                (<span class="keyword">int</span>)totalTimeDiff.TotalHours, totalTimeDiff.Minutes, totalTimeDiff.Seconds);</span><br><span class="line"></span><br><span class="line">            startTime = DateTime.MinValue;</span><br><span class="line">            endTime = DateTime.MinValue;</span><br><span class="line">            button1.Enabled = <span class="literal">true</span>;</span><br><span class="line">            button2.Enabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnClear_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            txtStart.Text = <span class="string">""</span>;</span><br><span class="line">            txtEnd.Text = <span class="string">""</span>;</span><br><span class="line">            txtTimeDiff.Text = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>注意：上述代码中的按钮单击事件处理程序是自动生成的，需要将它们与相应的按钮相关联。可以在 Visual Studio 的属性窗口中为每个按钮选择相应的事件处理程序。</p>
<p>可以在下图箭头所指的 click 右边可以修改按钮的事件名，将其关联起来。</p>
<p><img src="images/20230422_3.png" alt></p>
<p>如果是使用 Visual Studio 开发 Windows 窗体应用程序，可以在设计模式下双击按钮或者单击按钮然后在属性窗口中选择单击事件，在下拉菜单中选择对应的事件处理方法即可。</p>
<p>具体步骤如下：</p>
<ol>
<li>在 Visual Studio 中打开相应的窗体设计器。</li>
<li>选择要添加事件处理程序的按钮。</li>
<li>在属性窗口中查找事件属性（通常以“Events”为后缀）。</li>
<li>单击事件属性旁边的下拉箭头，选择相应的事件处理程序。</li>
<li>双击所选的事件处理程序名称，Visual Studio 将自动生成该事件的处理方法（这通常是一个空方法）。</li>
<li>在生成的方法中编写处理逻辑。</li>
</ol>
<p>注意：如果使用 C# 手动编写代码而不是通过设计器来添加事件处理程序，也可以在程序的入口点手动绑定按钮事件和处理程序。例如，在 Form1 类的构造函数中添加以下代码来绑定按钮单击事件：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Form1()</span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    <span class="built_in">this</span>.btnRecord.Click += <span class="keyword">new</span> <span class="type">EventHandler</span>(btnRecord_Click);</span><br><span class="line">    <span class="built_in">this</span>.btnPause.Click += <span class="keyword">new</span> <span class="type">EventHandler</span>(btnPause_Click);</span><br><span class="line">    <span class="built_in">this</span>.btnClear.Click += <span class="keyword">new</span> <span class="type">EventHandler</span>(btnClear_Click);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h2 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h2><p>使用 Visual Studio 的发布功能。具体步骤:</p>
<ol>
<li>在解决方案资源管理器中右键你的项目,选择 “发布”。</li>
<li>在发布向导中选择 “文件夹” 作为发布目标。这会直接发布成文件夹。</li>
<li>选中或取消选中需要发布的文件。一般保留默认选择即可。</li>
<li>点击发布按钮,选择发布位置。发布过程完成后,会在指定位置生成项目文件夹。 </li>
<li>将此项目文件夹压缩为 zip 文件。用户只需下载解压此 zip 文件,直接运行项目文件夹内的 exe 文件即可运行程序。</li>
<li>如果需要,也可以在发布后进一步使用 ILMerger、Costura 等工具将程序文件合并成单个 exe,以简化部署。  </li>
<li>还可以通过修改项目属性,更改输出类型为“Windows 应用程序”或“控制台应用程序”等，从而生成独立的 exe 可执行文件。 使用 Visual Studio 的一键发布功能,可以非常便捷地将 C# 项目打包为展示版本或发布版本。生成的文件夹或压缩包中包含项目运行所需的所有文件，用户只需要一键运行即可。 这种简单的发布方式适用于许多基本的应用程序,如果需要更专业的安装程序，可以使用 Installer 或 ClickOnce 等方式。</li>
</ol>
<p><img src="images/20230422_4.png" alt></p>
<p><img src="images/20230422_5.png" alt></p>
<p>使用 Visual Studio 发布功能生成的程序文件夹或者压缩包并非标准的安装程序，所以无法自动在桌面或开始菜单中生成快捷方式。 如果需要生成带有自动快捷方式和菜单项的标准安装程序，可以使用其它方法打包程序，方法如下:</p>
<ol>
<li>Installer 项目 - 可以生成 MSI 安装包,双击后可以自动安装程序，在桌面、开始菜单生成快捷方式和菜单项。适用于较复杂的应用程序安装,需要安装多个文件和注册表entries等。</li>
<li>ClickOnce 部署 - 可以生成基于浏览器的安装程序,点击后自动安装应用程序,并在桌面生成快捷方式。适用于较简单的应用程序,无需管理员权限安装。</li>
<li>Inno Setup - 这是一个开源软件,可以生成 exe 安装程序。安装后在桌面和开始菜单生成快捷方式。操作较简单，但功能也较简单,不支持复杂的安装步骤。</li>
<li>Advanced Installer - 这是一个付费软件，可以生成 MSI 或 exe 安装程序。功能强大,可以实现复杂的安装步骤和界面，安装后自动创建快捷方式和菜单。</li>
</ol>
<h2 id="修改图标"><a href="#修改图标" class="headerlink" title="修改图标"></a>修改图标</h2><p>要为应用程序修改图标,可以通过以下几种方法:</p>
<ol>
<li>修改项目属性中的应用程序图标: 在解决方案资源管理器中右键你的项目,选择“属性”。在弹出的属性页中,选中“应用程序”选项卡。在“图标”下，点击“更改图标”按钮，选择新的图标文件并确定即可。 这会更改 exe 文件和安装程序的默认图标。</li>
<li>软件左上角的小图标,称为任务栏图标或通知区图标。要修改这个图标，可以: 将新图标文件添加到 Visual Studio 解决方案资源管理器中的 “图标” 或 “图像”文件夹。然后:</li>
</ol>
<ul>
<li>双击新图标,选择“资源嵌入”选项。这会将图标嵌入到项目资源中。</li>
<li>打开主窗体(Form1)，在属性窗口点击“图标”属性旁的省略号按钮 (…)。</li>
<li>在“选择资源”对话框中，选择刚才嵌入的图标资源,确定。 这会更改主窗体和生成的 exe 的图标。</li>
</ul>
<p><img src="images/20230422_6.png" alt></p>
<p><img src="images/20230422_7.png" alt></p>
]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
</search>
